### 马士兵金融-后端文档

#### 1.项目介绍

##### 1.1 p2p金融介绍

> P2P金融又叫[P2P信贷](http://baike.baidu.com/view/4821410.htm)。其中，P2P是 peer-to-peer 或 person-to-person 的简写，意思是：[个人](http://baike.baidu.com/view/85269.htm)对个人。P2P金融指个人与个人间的小额借贷交易，一般需要借助电子商务专业网络平台帮助借贷双方确立借贷关系并完成相关交易手续。借款者可自行发布借款信息，包括金额、利息、还款方式和时间，实现自助式[借款](http://baike.baidu.com/view/588787.htm);借出者根据借款人发布的信息，自行决定借出金额，实现自助式借贷。
>
> P2P金融主要分为两种模式，基于电子商务的网络P2P金融和传统线下的P2P金融

##### 1.2.业务流程介绍

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/9ae3c66ec33243bfbf6590dbb72f1547.png)

##### 1.3 业务模块介绍

该项目包含如下几个模块：

```
1、会员注册、登录及认证
```

```
2、资产管理：包括资产统计、充值、提现等。
```

```
3、投资管理：包括资金的投资状态、交易记录等。
```

```
4、消息管理：站内信功能、分组群发。
```

```
5、账户管理：包括银行卡绑定，实名认证等。
```

```
6、债权管理：平台后台生成债权，债权信息记录。
```

```
7、投资管理：平台会员购买理财产品投资管理。
```

```
8、产品管理：理财产品管理功能。
```

```
9、奖励管理：用户邀请注册奖励功能。
```

```
11、撮合管理：撮合债权与购买投资的资金进行匹配。
```

#### 2.系统架构

- Flask 轻量级 Web 应用框架

> Flask是一个轻量级的可定制框架，使用Python语言编写，较其他同类型框架更为灵活、轻便、安全且容易上手。它可以很好地结合[MVC模式](https://baike.baidu.com/item/MVC%E6%A8%A1%E5%BC%8F/713147)进行开发，开发人员分工合作，小型团队在短时间内就可以完成功能丰富的中小型网站或[Web服务](https://baike.baidu.com/item/Web%E6%9C%8D%E5%8A%A1/2837593)的实现。另外，Flask还有很强的定制性，用户可以根据自己的需求来添加相应的功能，在保持核心功能简单的同时实现功能的丰富与扩展，其强大的插件库可以让用户实现个性化的网站定制，开发出功能强大的网站。

- SQLAlchemy

> SQLAlchemy是[Python](https://baike.baidu.com/item/Python/407313)编程语言下的一款开源软件。提供了SQL工具包及[对象关系映射](https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/311152)（ORM）工具.

我们主要用它来实现模型映射，并与数据库的交互。

- Redis

> Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供 多种语言的API。

我们使用它来实现注册等短信验证码的校验，过期自动删除的功能。

- Flask-RESTful

> Flask-RESTful 是一个 Flask 扩展，它添加了快速构建 REST APIs 的支持。它当然也是一个能够跟你现有的ORM/库协同工作的轻量级的扩展。
>
> RESTFUL特点包括：
>
> 1、每一个URI代表1种资源；
>
> 2、客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，
>
> POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；
>
> 3、通过操作资源的表现形式来操作资源；
>
> 4、资源的表现形式是XML或者 JSON；
>
> 5、客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需
>
> 的信息。
>
> 比如：(POST/PUT/GET/DELETE)

- MySQL

> MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。

#### 3.项目搭建

##### 3.1创建项目和虚拟环境

&#x3c;u>本项目编写python的IDE工具我们使用PyCharm&#x3c;/u>

- 新建项目，并同时创建虚拟环境

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/733a1bfe795c4a098b660a66c0907b00.png)

点击创建，稍作等待，项目就创建好了。

我们点击IDE右上角的运行项目按钮，就可以启动项目了。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/1d245183d1da4804bda7d138503846f3.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/85a733a47bbb49139ded4f69a0304725.png)

可以看到，我们的基本项目已经跑起来了，在游览器输入127.0.0.1：5000，可以看见返回内容

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/6d0ddd7d2e444c4499e8eba875a05b04.png)

##### 3.2 配置pip镜像源

Python里的pip是官方自带的源，国内使用pip安装的时候十分缓慢，所以最好是更换成中国国内的源地址。

1. 点击pycharm的文件，设置
2. 找到当前项目的解释器，点击+号

   ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/ddb7a9008bce4cf194c5f42820492cfb.png)
3. 点击管理库

   ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/2ed6c43b6e264a97bd3de3e60e33d4f7.png)
4. 修改镜像源 删掉默认的，新建 https://pypi.tuna.tsinghua.edu.cn/simple ，确定。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/3c56b874f90743a9b141458d7362a4ff.png)

##### 3.3 安装MySql

安装MySql,设置root账号密码为abc123456,创建数据库msb_financial（后面会在项目配置信息内写入这些）

##### 3.4 安装 SQLAlchemy

点击IDE下方的终端，可以看见终端路径就是我们当前的项目路径，并在前面有一个venv标识，说明我们当前是在虚拟环境当中，在虚拟环境当中安装的第三方包，都只在这个虚拟环境里。

输入pip install flask_sqlalchemy 回车确定，很快就安装好了。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/4b9a0c210ef94acf9aef70be23a1e952.png)

- 安装pymysql

  > PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库
  >

  ```
  pip install pymysql
  ```

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/471a0ce6f79b47ab8d4d03a2caba50a6.png)

##### 3.5 修改项目结构

- 在项目目录下创建Financial的包，并创建项目的启动文件，main.py,删掉初始项目目录下的app.py.

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/775675b0b76d442ab52a11b943786427.png)

- 添加项目的配置文件

  项目目录下新建settings包，创建一个default.py文件，写入项目的配置信息

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/f35c678d6b434ea6807861efe78e8c22.png)

  ```python

  ```

  settings下init文件

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/f0ed7797c3684247b064fd91a62c09eb.png)

```python
from .default import DevelopmentConfig
from .default import ProductConfig
# 把两个不同环境的配置和字符串映射起来
map_config = {
    'develop': DevelopmentConfig,
    'product': ProductConfig
}
```

- 在Financial下面的init文件里添加创建Flask的实例的方法，并在入口文件main里引用，创建Flask实例app

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/97248e94161c4a12865e3900e875a8aa.png)

```python
def create_app(config_type):
    app = Flask(__name__)
    # 加载项目的配置
    app.config.from_object(map_config.get(config_type))

    return app
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/b2b886b85b3141d8ae14bb31751095f6.png)

```python
from Financial import create_app

app = create_app('develop')

if __name__ == '__main__':
    app.run()

```

##### 3.6 初始化 sqlalchemy

在项目目录下新建comment包，下面新建models包，里面存放与数据库相关的文件。

在models下init文件里创建sqlalchemy对象，然后在创建Flask实例的地方，初始化sqlalchemy，与Flask实例app绑定。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/287e7679f82b40338133cf7d32b2c224.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/923a7fd54f5047f59be3b87de69e36ff.png)

##### 3.7 初始化 Redis

- 本机安装redis 数据库 安装包见附件 ...
- 为项目安装redis包 flask-redis

  ```
  pip install flask-redis
  ```

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/52ae9b3351a64faa8c7188ef1bfacc83.png)
- 创建实例化redis的文件，并在app创建的时候初始化redis实例，绑定flask核心对象app

  comment包下面创建utils包，下面创建financial_redis.py文件，写入实例化redis方法

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/9726bfeb85b8451bb3ae45fdf358e3da.png)

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/216545e98e334e2f95e25fa65fa0641d.png)

#### 4. 用户注册与登录

##### 4.1 user模型

- models下 新建user.py 模型文件，对应数据库中t_user表。

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/8939bbccae0545e5a99a16619944e42c.png)

```python
from comment.models import db
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash


# 用户的模型类
class User(db.Model):
    __tablename__ = 't_user'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True)
    username = db.Column(db.String(64), doc='用户名')
    password = db.Column(db.String(128), doc='密码')
    payPassword = db.Column(db.String(128), doc='支付密码')
    payPwdStatus = db.Column(db.Integer, doc='支付密码验证', default=0)
    email = db.Column(db.String(100), doc='邮箱')
    emailStatus = db.Column(db.Integer, doc='邮箱验证', default=0)  # 1代码正常
    inviteId = db.Column(db.Integer, doc='邀请码')
    ip = db.Column(db.String(128), doc='ip')
    phone = db.Column(db.String(11), doc='手机号')
    onlock = db.Column(db.Integer, doc='用户状态')  # 0代码正常
    phoneStatus = db.Column(db.Integer, doc='手机验证', default=1)  # 1代码正常
    realName = db.Column(db.String(64), doc='真实姓名')
    remark = db.Column(db.String(500), doc='备注')
    realNameStatus = db.Column(db.Integer, doc='实名认证', default=0)  # 代表已认证
    nick_name = db.Column(db.String(200), doc='昵称')
    avatar = db.Column(db.String(128), doc='头像')
    idNum = db.Column(db.String(64), doc='身份证号码')
    sumFriends = db.Column(db.Integer, doc='邀请数量统计')
    role = db.Column(db.Integer, doc='是否管理员', default=0)  # 0普通用户 1管理员

    loginTime = db.Column(db.DateTime, default=datetime.now(), doc='登录时间')
    registerTime = db.Column(db.DateTime, default=datetime.now(), doc='用户注册的时间')

    # 是一个pwd属性的getter函数

    @property
    def pwd(self):
        return self.password

    # 是一个pwd属性的setter函数

    @pwd.setter
    def pwd(self, x_password):
        """
        根据明文的密码，转换成密文
        :param x_password: 密码的明文
        :return: 加密之后的密文
        """
        self.password = generate_password_hash(x_password)  # 根据flask提供的算法来加密

    def check_password(self, x_password):
        """
        验证密码
        :param x_password:  明文
        :return:
        """
        return check_password_hash(self.password, x_password)

    @property
    def pay_pwd(self):
        """
        支付密码
        """
        return self.payPassword

    @pay_pwd.setter
    def pay_pwd(self, p_password):
        self.payPassword = generate_password_hash(p_password)  # 根据flask提供的算法来加密

    def check_pay_password(self, p_password):
        return check_password_hash(self.payPassword, p_password)

```

##### 4.2 account模型

models下新建account.py 模型文件，对应数据库中t_account表(用户账户表)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/943f100b319e4ccca64942b7541e0253.png)

```python
from sqlalchemy import ForeignKey
from comment.models import db


# 用户账户的模型类
class Account(db.Model):
    __tablename__ = 't_account'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    userId = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户表主键')
    user = db.relationship('User', backref=db.backref('accountInfo', lazy=True, uselist=False))
    total = db.Column(db.Float(10, 2), doc='帐户总额', default=0)
    balance = db.Column(db.Float(10, 2), doc='帐户可余额', default=0)
    frozen = db.Column(db.Float(10, 2), doc='账户总计冻结总额', default=0)
    inverstmentW = db.Column(db.Float(10, 2), doc='总计待收本金', default=0)
    interestTotal = db.Column(db.Float(10, 2), doc='总计待收利息', default=0)
    addCapitalTotal = db.Column(db.Float(10, 2), doc='月投总额', default=0)
    recyclingInterest = db.Column(db.Float(10, 2), doc='月取总额', default=0)
    capitalTotal = db.Column(db.Float(10, 2), doc='月乘总额', default=0)
    inverstmentA = db.Column(db.Float(10, 2), doc='已投资总额', default=0)
    interestA = db.Column(db.Float(10, 2), doc='已赚取利息', default=0)
    uApplyExtractMoney = db.Column(db.Float(10, 2), doc='申请提现金额', default=0)
    discount = db.Column(db.Float(8, 2), doc='代金券', default=0)

```

##### 4.3 创建数据库表

使用 Flask-Migrate同步user,account模型类，创建数据库表。Migrate详细使用请参照相关文档

##### 4.4 创建序列化器基类

> 序列化器的作用就是把要返回给前端的数据给转换成可以被json格式化的数据，并且可以自定义具体返回数据的名称和格式，具体返回什么样，可以和前端协商。

- utils包下创建serializers.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c125968d0e1441459c64dd0076a60940.png)

```python
#codeing:utf-8

class BasePaginateSerializer(object):
    """分页数据序列化基类"""

    def __init__(self, paginate):
        self.pg = paginate
        if not self.pg:
            return paginate
        self.has_next = self.pg.has_next  # 是否还有下一页
        self.has_prev = self.pg.has_prev  # 是否还有下一页
        self.next_num = self.pg.next_num  # 下一页的页码
        self.page = self.pg.page  # 当前页的页码
        self.pages = self.pg.pages  # 匹配的元素在当前配置一共有多少页
        self.total = self.pg.total  # 匹配的元素总数

    def get_object(self, obj):
        """对象的内容,系列化的个性操作,子类重写"""
        return {}

    #
    def paginateInfo(self):
        """分页信息，是否有上下页，页数，总页数等"""
        return {
            'has_next': self.has_next,
            'has_prev': self.has_prev,
            'next_num': self.next_num,
            'page': self.page,
            'pages': self.pages,
            'total': self.total
        }

    def to_dict(self):
        """序列化分页数据"""
        pg_info = self.paginateInfo()
        paginate_data = []
        for obj in self.pg.items:
            paginate_data.append(self.get_object(obj))
        return {
            'paginateInfo': pg_info,
            'totalElements': pg_info['total'],
            'content': paginate_data
        }


class BaseSerializer(object):
    """对象序列化基类"""
    def __init__(self, data):
        self.data = data

    def to_dict(self):
        """个性化的系列化,子类重写 """
        return {}


class BaseListSerializer(object):
    """对象组序列化基类"""
    def __init__(self, data):
        self.data_list = data
        self.select_type_serializer()

    def select_type_serializer(self):
        if not self.data_list:
            return None
        if isinstance(self.data_list, list):  # 列表解析
            if len(self.data_list) == 0:
                return None
            else:
                self.data_list = [dict(zip(result.keys(), result)) for result in self.data_list]

    def to_dict(self):
        """个性化的系列化,子类重写 """
        return {}

```

##### 4.5 user_resource(注册，登录，退出)

- 安装Flask-RESTful

  > 控制台输入 pip install Flask-RESTful
  >
- 创建一个user相关的常量文件，保存相关设置参数

  user包下，新建constants.py，保存相关设置。

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/a6fddc259e18468a8f294e8feff38e96.png)
- 创建user相关的api资源以实现restful风格的接口

  在Financial目录下新建resource包，下面再创建一个user包，user包下面再创建一个user_resource.py

  user_resource.py文件里面实现用户相关的api资源。（注册，判断手机号是否重复，发送验证码）

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/3ccf44da362f4a1b84a4c6803e12cabc.png)
- 用户注册

```python
class RegisterUser(Resource):
    """
    用户的注册
    """
    def post(self):
        rp = RequestParser()
        rp.add_argument('phone', required=True)     # 设置要从请求中的参数，required为必填
        rp.add_argument('username', required=True)
        rp.add_argument('password', required=True)
        rp.add_argument('code', required=True)
        rp.add_argument('invite_code')

        args = rp.parse_args()  # 验证参数

        # 用户名
        username = args.username  # 获取参数
        # 密码
        password = args.password
        # 手机
        phone = args.phone
        # 验证码
        code = args.code
        # 邀请码
        invite_code = args.invite_code

        # 验证用户名是否唯一
        u = User.query.filter(User.username == username).first()
        if u:  # 用户名已经存在
            current_app.logger.info('{}:用户名已经存在，请换一个'.format(username))
            return {'message': '用户名已存在.'}, 400

        # 从redis数据库中得到之前保存的验证码
        key = 'registerCode:{}'.format(phone)
        try:
            real_code = redis_client.get(key)  # 从redis中返回的是字节数据
        except ConnectionError as e:
            current_app.logger.error(e)
            return {"code": 20001, 'message': 'redis db connect error.'}
        # 开始校验
        if not real_code or real_code.decode() != code:
            return {'message': '验证码错误或已失效'}, 400

        # 把用户信息保存到数据库中
        u = User(username=username, pwd=password, phone=phone, onlock=0)
        # 如果有 邀请码，则验证一下
        if invite_code:
            self.checkInvite(u, invite_code)
        db.session.add(u)
        db.session.commit()
        account = Account(userId=u.id)  # 创建了用户，同时创建一个用户账户
        db.session.add(account)
        db.session.commit()

        return {'msg': '注册成功'}

    # 验证邀请码
    def checkInvite(self, user, code):
        code = code.strip()
        checkUser = User.query.filter(User.remark == code).first()  # 查询是否是用户生成的有效邀请码
        if checkUser:
            user.sumFriends = checkUser.id  # 邀请码有效,登记邀请人的id到账户
            checkUser.accountInfo.discount += 50  # 邀请人增加50代金券
```

- 判断手机号是否重复

```python
class IsExistPhone(Resource):
    """
    判断手机号是否存在
    """
    def post(self):
        phone = request.json.get('phone')
        user = User.query.filter(User.phone == phone).first()
        if user:
            return {'message': '此手机已注册', 'code': 20001}
        return {'msg': '此手机可以注册'}
```

- 发送短信验证码

```python
class SmsCode(Resource):
    """
    发送验证码的短信，
    """

    def get(self):
        phone = request.args['phone'].strip()
        import random
        code = random.randint(1000, 9999)
        # 前端显示的看到短信验证码发送成功之后，还需要把验证码存放到redis数据库中，以便于下次验证，验证码的时效为5分钟
        redis_client.setex('registerCode:{}'.format(phone), constants.SMS_CODE_EXPIRES, code)  # 参数1：key,参数2：时效

        return {'smsCode': code}
```

- 用户登录

  用户登录的功能我们使用 &#x3c;u>Json Web Token(JWT)&#x3c;/u> 来为登录用户生成token令牌，并返回给客户端，客户端有了令牌之后，每次访问服务器，都携带Token，后台经过验证就能知道当前登录的用户是谁，以实现鉴权，权限控制。

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/96b3b0eab7574c1cbe52d55531ec0f73.png)

  - **什么是JWT**

    > JWT（JSON WEB
    > TOKEN）：JSON网络令牌，JWT是一个轻便的安全跨平台传输格式，定义了一个紧凑的自包含的方式在不同实体之间安全传输信息（JSON格式）。它是在Web环境下两个实体之间传输数据的一项标准。实际上传输的就是一个字符串。
    >
  - **JWT用来做什么？怎么来的？**

    > 由于http协议是无状态的，所以客户端每次访问都是新的请求。这样每次请求都需要验证身份，传统方式是用session+cookie来记录/传输用户信息，而JWT就是更安全方便的方式。它的特点就是简洁，紧凑和自包含，而且不占空间，传输速度快,而且有利于多端分离，接口的交互等等
    > JWT是一种Token规范，主要面向的还是登录、验证和授权方向，当然也可以用只来传递信息。一般都是存在header里，也可以存在cookie里。
    >
  - 安装 包 pyjwt

    终端里输入

    > pip install pyjwt
    >

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c090506c030b4fdd89496c62afc6e9a2.png)
  - 创建生成token和验证token的方法

    utils包下创建const.py （存放生成token相关的设置参数）

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/f3c5f21b26b34cbea1fa28fc09bc5079.png)

    ```python
    SECRET_KEY = os.urandom(16)  # 生成一个随机数作为秘钥
    JWT_EXPIRY_SECOND = 600 * 60  # TOKEN的有效时间
    ```

    utils包下创建tokens_pyjwt.py （生成token,验证token）

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/35dd9f8fb7db4ad98defed18c87f5258.png)

    ```python
    import jwt
    from jwt import PyJWTError

    from comment.utils import const
    from flask import current_app
    from comment.models.user import User
    from datetime import datetime, timedelta


    def generate_tokens(uid):
        """
        根据已经登录之后的用户ID，生成token
        :param uid: 用户ID
        :return:
        """
        payload = {
            'id': uid,
            # exp代表token有效时间，而且必须是标准时间
            'exp': datetime.utcnow() + timedelta(seconds=const.JWT_EXPIRY_SECOND)
        }
        # 参数1: payload是一个字典包括加密的用户ID和有效时间，参数2：秘钥，参数3： 算法
        s = jwt.encode(payload=payload,key=const.SECRET_KEY, algorithm='HS256')
        # 生成token
        return s


    def verify_tokens(token_str):
        """
        验证token，并且验证成功之后，返回用户ID
        :param token_str:
        :return:
        """
        try:
            # 本质上就是一个解密的过程
            data = jwt.decode(token_str, key=const.SECRET_KEY, algorithms='HS256')
            current_app.logger.info(data)
        except PyJWTError as e:
            current_app.logger.info(e)
            return {'message': 'token 验证失败'}
        # 如果token验证成功，还需要看看当前用户状态是否正常
        user = User.query.filter(User.id == data['id']).first()
        if user and user.onlock != 0:
            return {'message': '数据库中的用户状态过期'}
        return {'id': user.id}
    ```
  - 登录的视图函数

    回到user_resource.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/9b81c4519bc4482581bbe61567e01481.png)

    ```python
    class Login(Resource):
        """
            登录
            """
        def post(self):
            rp = RequestParser()
            rp.add_argument('username', required=True)
            rp.add_argument('password', required=True)
            args = rp.parse_args()
            username = args.username
            password = args.password

            if not all([username, password]):
                return {'message': '数据不完整', "code": 20001}
            user = User.query.filter(User.username == username).first()
            if user:
                if user.check_password(password):
                    # 用登录成功之后的用户的ID生成token，再返回给前端
                    token = generate_tokens(user.id)
                    current_app.logger.info(verify_tokens(token))
                    return {'token': token}
            return {'message': '用户名或者密码错误.', "code": 20001}
    ```
  - 定义一个请求钩子函数，验证token，把验证成功之后的用户ID保存到全局变量g中

    utils包下创建request_auth.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/1950adf574ec47efabf74a28b6d24b32.png)

    ```python
    """
    定义请求钩子： 在请求进来之前得到request携带的token，并且验证token
    """
    from flask import g, request, current_app
    from comment.utils.tokens_pyjwt import verify_tokens


    def jwt_request_auth():
        """
        自定义一个请求钩子函数，验证token，并且把验证成功之后的用户ID保存到全局变量g中
        :return:
        """
        g.user_id = None # 定义一个变量user_id

        token = request.headers.get('token')

        if token is not None:
            result = verify_tokens(token)
            if 'id' in result:  # 如果验证成功，那么字典中一定有用户ID
                g.user_id = result['id']
    ```

    在app的before_request绑定定义的请求钩子，实现每次访问都应用钩子函数，先查询是否有token,验证

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/e61ca446aa384165895b5ce76344ff79.png)
- 退出登录视图函数

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/5bf3b3e5f96349eebb21bc98a40df661.png)

  ```python
  class LoginOut(Resource):
      """
      退出登录
      """
      def post(self):
          if g.user_id:
              g.user_id = None
          return {'msg': 'logout Done'}
  ```
- 创建一个自定义的json返回格式

  utils包下创建output.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/7401d8c92e974951847f17d96ccfe529.png)

  **此自定义的返回的意义是，如果请求没有错误(默认的返回信息里没有message字段的话)，我们都返回http状态码200,请求成功，给原来的返回数据封装一层，并在data的同级加入信息message:'ok'.**

  **如果原响应对象有message字段则不进行封装，返回原响应对象和响应的状态码。**
- 创建蓝图，将api资源类与蓝图绑定

  在user包下的init文件创建蓝图，创建api资源

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/cbdde23f6d4240b6ad5bce8982880d1f.png)

  ```python
  # 用户模块下的蓝图，包括用户模块的所有资源
  from flask import Blueprint
  from flask_restful import Api
  from comment.utils.output import output_json

  user_bp = Blueprint('users', __name__, url_prefix='/user')  # 创建蓝图
  user_api = Api(user_bp)  # 创建蓝图中的资源API


  # 使用我们自定义json格式，替代装饰器的写法
  user_api.representation('application/json')(output_json)

  # 加载当前模块的资源
  from Financial.resources.user.user_resource import RegisterUser, IsExistPhone, \
      SmsCode, Login, LoginOut


  user_api.add_resource(RegisterUser, '/user-register', endpoint='user-register')
  user_api.add_resource(IsExistPhone, '/isExist', endpoint='isExist')
  user_api.add_resource(SmsCode, '/sms', endpoint='sms')
  user_api.add_resource(Login, '/login', endpoint='login')
  user_api.add_resource(LoginOut, '/loginOut', endpoint='loginOut')


  ```
- 在Flask实例app上注册蓝图

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/9547062a2ca64aafadffb2f88a5ad1e3.png)

---

#### 5.站内信功能

##### 5.1 创建模型

models下面新建，信件 letter.py  和信件详情 letter_detail.py 2个文件，写入相关字段。

- letter.py

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/a42265f6b8f14e5aaecacd5e0891e6e4.png)

```python
# 站内信的模型类
class Letter(db.Model):
    __tablename__ = 't_letter'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True)
    sendID = db.Column(db.String(64), doc='发送者名字')
    recID = db.Column(db.BIGINT, doc='接受者ID')
    detail_id = db.Column(db.BIGINT, ForeignKey('t_letter_detail.id'), doc='消息详情主键')
    letter_detail = db.relationship('Letter_detail', backref=db.backref('letter', lazy=True))
    state = db.Column(db.Integer, doc='持否已读（0未读；1已读）')
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/9b55b5751b304070b4ff68f784dc9f10.png)

```
# 站内信详情的模型类
class Letter_detail(db.Model):
    __tablename__ = 't_letter_detail'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True)
    title = db.Column(db.String(64), doc='消息标题')
    detail = db.Column(db.String(256), doc='消息内容')
    pDate = db.Column(db.DateTime, default=datetime.now(), doc='发送时间')
```

##### 5.2 创建API资源，编写接口

- resources下新建letter包
- 创建信件资源的序列化器，在letter包下新建serializer.py
- letter的分页序列化器是继承了基础的分页序列化基类，所以只要实现具体的序列化方法（get_object）即可,其他在基类里完成，调用的时候只需要在初始化时传入分页对象，并调用.to_dict()完成分页序列化

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/ceacb0ea7893425fa9b846178789eed6.png)
- letter包下新建letter_resource.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/5bbc8c3bacc24a1396408907a5974103.png)

  ```python
  from flask import g
  from flask_restful import Resource
  from flask_restful.reqparse import RequestParser
  from Financial.resources.letter.serializer import LetterPaginateSerializer
  from comment.models import db
  from comment.models.letter import Letter
  from comment.models.letter_detail import Letter_detail
  from comment.models.user import User


  class Letter(Resource):

      # 发送信件
      def post(self):
          rp = RequestParser()
          rp.add_argument('title', required=True)  # 标题
          rp.add_argument('group', required=True)  # 用户组
          rp.add_argument('content', required=True)  # 消息内容
          args = rp.parse_args()
          title = args.get('title')
          group = int(args.get('group'))
          content = args.get('content')

          uid = g.user_id
          user = User.query.filter(User.id == uid).first()

          if user:
              # 创建信件详情记录
              new_letter_detail = Letter_detail(title=title, detail=content)
              db.session.add(new_letter_detail)
              db.session.flush()

              #  用户组按权限划分，goup值 2:全体用户 0：普通用户, 1:管理组
              if group != 2:
                  recList = User.query.filter(User.role == group).all()
              else:
                  recList = User.query.all()
              for u in recList:
                  # 根据筛选的用户组插入信件记录到数据库
                  letter = Letter(sendID=user.username, recID=u.id, detail_id=new_letter_detail.id, state=0)
                  db.session.add(letter)
                  db.session.flush()
              db.session.commit()
              return {'msg': 'ok'}
          else:
              return {'message': '未登录', 'code': 20008}

      # 查询信件
      def get(self):
          rp = RequestParser()
          rp.add_argument('curPage', required=True)  # 标题
          rp.add_argument('perPage', required=True)  # 用户组
          args = rp.parse_args()
          curPage = int(args.get('curPage'))
          perPage = int(args.get('perPage'))

          uid = g.user_id
          cu = User.query.filter(User.id == uid).first()
          if cu:
              lettersList = Letter.query.filter(Letter.recID == cu.id).paginate(curPage, perPage, error_out=False)
              data = LetterPaginateSerializer(lettersList).to_dict()
              return {'msg': "ok", "data": data}
          else:
              return {'message': '未登录', 'code': 20008}

      # 删除信件
      def delete(self):
          rp = RequestParser()
          rp.add_argument('message_id', required=True)  # 标题
          args = rp.parse_args()
          m_id = args.get('message_id')

          letter = Letter.query.filter(Letter.id == m_id)
          if letter:
              letter.delete()
              db.session.commit()
              return {'msg': "ok"}
          else:
              return {'message': "此消息不存在", 'code': 20005}

      # 更新信件（已读状态）
      def put(self):
          rp = RequestParser()
          rp.add_argument('message_id', required=True)  # 标题
          args = rp.parse_args()
          m_id = args.get('message_id')

          letter = Letter.query.filter(Letter.id == m_id).first()
          if letter:
              letter.state = 1
              db.session.commit()
              return {'msg': "ok"}
          else:
              return {'message': "此消息不存在", 'code': 20005}


  ```

##### 5.3 创建蓝图，绑定api资源，注册

letter包下init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/2d4b9d2fbf644f1a8832fdd82905f1c5.png)

```python
# 站内信模块下的蓝图，包括信件的所有资源
from flask import Blueprint
from flask_restful import Api
from comment.utils.output import output_json

notify_bp = Blueprint('notify', __name__, url_prefix='/notify')  # 创建蓝图
letter_api = Api(notify_bp)  # 创建蓝图中的资源API

# 使用我们自定义json格式，替代装饰器的写法
letter_api.representation('application/json')(output_json)

# 加载当前模块的资源
from Financial.resources.letter.letter_resource import Letter

letter_api.add_resource(Letter, '/message', endpoint='message')


```

- 在flask实例上注册蓝图

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/017591b2fdb04758887c4d9efcee5753.png)

#### 6.银行卡

##### 6.1 创建模型

models下面新建，银行卡  bank_card.py 写入相关字段。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/cbb55acdbb9f42968017c5c3be3a5384.png)

```python
# 银行卡信息的模型类
class BankCard(db.Model):
    __tablename__ = 't_bankcard'
    bankInfoId = db.Column(db.Integer, primary_key=True, autoincrement=True)
    bankCardNum = db.Column(db.String(64), doc='银行卡号')
    openingBank = db.Column(db.String(64), doc='开户银行')
    cityId = db.Column(db.Integer, doc='城市id')
    userId = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户表主键')
    user = db.relationship('User', backref=db.backref('bankCards', lazy=True))
    bankId = db.Column(db.Integer, doc='银行编号')
    bankBranch = db.Column(db.String(64), doc='银行支行')
    reservePhone = db.Column(db.String(64), doc='绑定手机号码')
```

##### 6.2 创建API资源，编写接口

- resources下新建card包
- 创建信件资源的序列化器，在card包下新建serializer.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/730072db8dc6445396420b6f55de99c9.png)

  ```python
  from comment.utils.serializers import BaseListSerializer

  '''
      序列化
  '''


  class BankCardListSerializer(BaseListSerializer):
      """银行卡列表的序列化"""

      def to_dict(self):
          list = []
          for obj in self.data_list:
              list.append(
                  {
                      'card_id': obj.bankInfoId,
                      'cardNum': obj.bankCardNum,
                      "bankName": obj.openingBank,
                  }
              )
          return list
  ```
- card包下新建card_resource.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/b3b449002cc8478c970fc917ca31651c.png)

  ```python
  from flask import g
  from flask_restful import Resource
  from flask_restful.reqparse import RequestParser
  from Financial.resources.card.serializer import BankCardListSerializer
  from comment.models import db
  from comment.models.bank_card import BankCard
  from comment.models.user import User


  class Card(Resource):

      def post(self):
          rp = RequestParser()
          rp.add_argument('holder', required=True)
          rp.add_argument('openingBank', required=True)  # 开户银行
          rp.add_argument('bankBranch', required=True)  # 支行
          rp.add_argument('cityId', required=True)  # 城市id
          rp.add_argument('cardNum', required=True)  # 卡片号码

          args = rp.parse_args()

          openingBank = args.openingBank
          bankBranch = args.bankBranch
          cityId = args.cityId
          bankCardNum = args.cardNum

          uid = g.user_id
          cu = User.query.filter(User.id == uid).first()

          # 验证银行卡是否唯一
          cardInfo = BankCard.query.filter(BankCard.bankCardNum == bankCardNum).first()

          if cardInfo:  # 银行卡信息已存在 不存在一卡多人
              return {'message': '银行卡已存在,请勿重复添加', 'code': 20011}
          # 把银行卡信息保存到数据库中
          card = BankCard(bankCardNum=bankCardNum, openingBank=openingBank, bankBranch=bankBranch, cityId=cityId,
                          userId=cu.id, reservePhone=cu.phone)
          db.session.add(card)
          db.session.commit()

          return {'msg': "success"}

      def get(self):

          uid = g.user_id

          # 获取当前用户下的所有银行卡
          cardInfo = BankCard.query.filter(BankCard.userId == uid).all()
          if cardInfo:
              data_cardInfo = BankCardListSerializer(cardInfo).to_dict()
              return data_cardInfo
          else:
              return {}

      def delete(self):
          rp = RequestParser()
          rp.add_argument('cardNum', required=True)

          args = rp.parse_args()
          bankCardNum = args.cardNum

          cardInfo = BankCard.query.filter(BankCard.bankCardNum == bankCardNum)
          if cardInfo:
              cardInfo.delete()
              db.session.commit()
              return {'msg': 'success'}
          else:
              return {"code": 20008, 'message': 'no this card'}

  ```

##### 6.3 创建蓝图，绑定api资源，注册

card包下init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/6cf361e9284041709a84cf520eaa4ddd.png)

```
# 银行卡模块下的蓝图，包括银行卡模块的所有资源

from flask import Blueprint
from flask_restful import Api
from comment.utils.output import output_json

card_bp = Blueprint('cards', __name__, url_prefix='/card')  # 创建蓝图
card_api = Api(card_bp)  # 创建蓝图中的资源API

# 使用我们自定义json格式，替代装饰器的写法
card_api.representation('application/json')(output_json)

# 加载当前模块的资源
from Financial.resources.card.card_resource import Card


card_api.add_resource(Card, '/card', endpoint='card')

```

- 在flask实例上注册蓝图

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/81af88109a194be4b90fceb510c628be.png)

#### 7. 理财产品\投资记录\交易记录

> 在实现充值，提现，购买理财产品等功能之前，需要先创建理财产品，投资记录，交易记录等模型类。

##### 7.1创建模型

models下新建

- product.py（理财产品）
- product_rate.py(理财产品利率)
- invest_record.py(投资记录)
- deal_record.py(交易记录)

写入对应的字段

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/50dc173ae8cd4532831cc75eeaffad05.png)

```python
from comment.models import db


# 理财产品的模型类
class Product(db.Model):
    __tablename__ = 't_product'
    proId = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='产品id')
    productName = db.Column(db.String(100), doc='产品名称')
    closedPeriod = db.Column(db.BIGINT, doc='转让封闭期', default=12)
    earlyRedeptionType = db.Column(db.Integer, doc='提前赎回类型', default=1)
    earningType = db.Column(db.Integer, doc='收益利率类型', default=134)
    investRule = db.Column(db.Integer, doc='数量规则', default=10)
    isAllowTransfer = db.Column(db.Integer, doc='是否可转让', default=0)
    isRepeatInvest = db.Column(db.Integer, doc='是否复投', default=0)
    lowerTimeLimit = db.Column(db.Integer, doc='产品最低期限', default=3)
    proLowerInvest = db.Column(db.BIGINT, doc='产品起投金额', default=1000)
    proNum = db.Column(db.String(100), doc='产品编号')
    proUpperInvest = db.Column(db.BIGINT, doc='产品投资上限', default=300000)
    proTypeId = db.Column(db.Integer, doc='产品投资上限', default=1)  # (1:表示正常；0：表示停用)
    status = db.Column(db.Integer, doc='状态', default=1)
    upperTimeLimit = db.Column(db.Integer, doc='产品最大期限', default=36)
    wayToReturnMoney = db.Column(db.Integer, doc='回款方式', default=109)  # （109：表示一次性回款 ，110：每月提取，到期退出）

```

---

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/a70695a142954d92853be2b8027c3dcd.png)

```python
from comment.models import db
from sqlalchemy import ForeignKey


# 理财产品利率表
class Product_rate(db.Model):
    __tablename__ = 't_product_rate'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='编号')
    incomeRate = db.Column(db.Float(4, 2), doc='利率值')
    month = db.Column(db.Integer, doc='月份', default=12)
    productId = db.Column(db.BIGINT, ForeignKey('t_product.proId'), doc='产品编号')
    product = db.relationship('Product', backref=db.backref('rateInfo', lazy=True))

```

---

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c5284dcd693b422eafbf491ebbf6b527.png)

```python
from comment.models import db
from datetime import datetime
from sqlalchemy import ForeignKey

# 用户投资记录表
class Invest_record(db.Model):
    __tablename__ = 't_invest_record'
    pId = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='主键')
    pProductId = db.Column(db.BIGINT, ForeignKey('t_product.proId'), doc='产品id')
    product = db.relationship('Product', backref=db.backref('investRecord', lazy=True))
    pUid = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户id')
    user = db.relationship('User', backref=db.backref('investRecord', lazy=True))
    pSerialNo = db.Column(db.String(64), doc='投资编号')
    pBeginDate = db.Column(db.DateTime, default=datetime.now(), doc='加入日期')
    pEndDate = db.Column(db.DateTime, doc='到期日期')
    pRedeemDate = db.Column(db.DateTime, doc='赎回日期')
    pMatchDate = db.Column(db.DateTime, doc='匹配日期')
    pAmount = db.Column(db.Float(8, 2), doc='金额')
    pDate = db.Column(db.DateTime, default=datetime.now(), doc='系统时间')
    pProductType = db.Column(db.Integer, doc='收益利率类型')
    pEarningsType = db.Column(db.String(100), doc='产品编号')
    pProductType = db.Column(db.Integer, doc='收益率类型')
    pEarnings = db.Column(db.Float(4, 2), doc='收益率')
    pAdvanceRedemption = db.Column(db.Float(4, 2), doc='提前赎回利率')
    pDeadline = db.Column(db.Integer, doc='选择期限')
    aCurrentPeriod = db.Column(db.Integer, doc='当前期（账户资金日志表）')
    pProspectiveEarnings = db.Column(db.Float(8, 2), doc='预期收益')
    pExpectedAnnualIncome = db.Column(db.Float(4, 2), doc='预期年化收益')
    pMonthInterest = db.Column(db.Float(8, 2), doc='每月盈取利息')
    pMonthlyExtractInterest = db.Column(db.Float(8, 2), doc='每月提取利息')
    pInterestStartDate = db.Column(db.DateTime, doc='开始计息时间')
    pInterestEndDate = db.Column(db.Integer, doc='结束计息时间')
    pEarningsIsFinished = db.Column(db.Float(10, 2), doc='收益是否完成')
    pAvailableBalance = db.Column(db.Float(10, 2), doc='可用余额')
    pFrozenMoney = db.Column(db.Float(10, 2), doc='冻结金额')
    pSystemPaymentDate = db.Column(db.Integer, doc='每月回款日')
    pCurrentMonth = db.Column(db.Integer, doc='当前期（用户购买产品记录表）')
    pDeductInterest = db.Column(db.Float(8, 2), doc='扣去利息')
    pNotInvestMoney = db.Column(db.Float(10, 2), doc='未投资金额')
    pStatus = db.Column(db.Integer, doc='状态')
    pEndInvestTotalMoney = db.Column(db.Float(8, 2), doc='到期应回总本息')
    pCurrentRealTotalMoney = db.Column(db.Float(8, 2), doc='当前期实回总本息')
    pDeadlineCount = db.Column(db.Float(8, 2), doc='统计')
    pProductName = db.Column(db.String(32), doc='产品名称')
    pMonthlyDeposit = db.Column(db.Float(8, 2), doc='月存')
    pMonthlyDepositCount = db.Column(db.Integer, doc='月存笔数')
    pTakeMonth = db.Column(db.Float(8, 2), doc='月乘')
    pTakeMonthCount = db.Column(db.Integer, doc='月乘笔数')
    pMayTake = db.Column(db.Float(8, 2), doc='月取')
    pMayTakeCount = db.Column(db.Integer, doc='月取笔数')
    pTotalAsDay = db.Column(db.Integer, doc='总天数')
    pDeadlineAsDay = db.Column(db.Integer, doc='投资天数')
    pDays = db.Column(db.Integer, doc='天数')
    pDeadlines = db.Column(db.DateTime, doc='投资期限')
    username = db.Column(db.String(64), doc='投资用户名')
    pEarnedInterest = db.Column(db.Float(8, 2), doc='已赚取利息')
    pRemark = db.Column(db.String(64), doc='备注')
    sumAvailableBalanceAndFrozenMoney = db.Column(db.Float(8, 2), doc='SUM(可用余额+冻结金额)')
    pTotal = db.Column(db.Float(8, 2), doc='总计')
```

---

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/ba6ffe217b3a43b7a726813c1d96cb6c.png)

```python
from datetime import datetime
from comment.models import db
from sqlalchemy import ForeignKey


# 交易记录的模型类
class DealRecord(db.Model):
    __tablename__ = 't_deal_log'
    aId = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='主键')
    aUserId = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户id')
    user = db.relationship('User', backref=db.backref('deal_log', lazy=True))
    pId = db.Column(db.BIGINT, ForeignKey('t_invest_record.pId'), doc='投资记录主键')
    investRecord = db.relationship('Invest_record', backref=db.backref('deal_log', lazy=True))
    aCurrentPeriod = db.Column(db.Integer, doc='当前期')
    aReceiveOrPay = db.Column(db.Float(8, 2), doc='收付')
    aTransferSerialNo = db.Column(db.String(128), doc='交易流水号')
    aDate = db.Column(db.DateTime, default=datetime.now(), doc='交易时间')
    aType = db.Column(db.Integer, doc='交易类型', default=0)
    aTransferStatus = db.Column(db.Integer, doc='交易状态', default=0)
    aBeforeTradingMoney = db.Column(db.Float(8, 2), doc='交易前金额', default=0)
    aAmount = db.Column(db.Float(8, 2), doc='金额', default=0)
    aAfterTradingMoney = db.Column(db.Float(8, 2), doc='交易后金额', default=0)
    aDescreption = db.Column(db.String(128), doc='交易详情')
```

##### 7.2创建API资源，编写接口

- resources下新建product包
- 创建产品资源的序列化器，在product包下新建serializer.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/d72e44efba79440faa77a103c7da158a.png)

  ```python
  from comment.utils.serializers import BaseListSerializer
  '''
      序列化
  '''


  class ProductListSerializer(BaseListSerializer):
      """产品列表的序列化"""

      def to_dict(self):
          list = []
          for obj in self.data_list:
              list.append(
                  {
                      'id': obj.proId,
                      'proNum': obj.proNum,
                      'productName': obj.productName,
                      'minLimit': obj.lowerTimeLimit,
                      'maxLimit': obj.upperTimeLimit,
                      'earning': '年利率' if obj.earningType == 134 else '月利率',
                      'ReturnMoney': '一次性回款' if obj.wayToReturnMoney == 110 else '每月部分回款',
                      'closedPeriod': obj.closedPeriod,
                      'status': obj.status,
                      'proLowerInvest': obj.proLowerInvest
                  }
              )
          return list


  class ProductRateListSerializer(BaseListSerializer):
      """产品利率的序列化"""

      def to_dict(self):
          list = {}
          for obj in self.data_list:
              list.update({
                  obj.month:
                      {
                          'id': obj.id,
                          'proId': obj.productId,
                          'month': obj.month,
                          'incomeRate': float(obj.incomeRate)
                      }
              }
              )
          return list



  ```
- product包下新建 product_resource.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/39ff958a824449c8be4be97cbed74723.png)

  ```python
  from importlib.resources import Resource
  from flask_restful.reqparse import RequestParser
  from Financial.resources.product.serializer import ProductListSerializer, ProductRateListSerializer
  from comment.models.product_rate import Product_rate
  from comment.models.pruduct import Product


  class Product(Resource):
      """
      理财产品
      """

      def get(self):
          productList = Product.query.all()  # 查询出所有的产品
          data = ProductListSerializer(productList).to_dict()

          return {'msg': 'success', 'data': data}


  class ProductRate(Resource):
      """
      产品利率
      """

      def get(self):
          rp = RequestParser()
          rp.add_argument('proId', required=True)  # 产品ID
          args = rp.parse_args()
          proId = args.proId
          rateList = Product_rate.query.filter(Product_rate.productId == proId).all()  # 根据产品id查询产品利率
          data = ProductRateListSerializer(rateList).to_dict()

          return {'msg': 'success', 'data': data}

  ```
- 投资/交易记录的资源

  resources下新建transaction包

  创建投资记录的序列化器 transaction包下新建serializer.py

  - 投资记录的序列化

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/d887947595d848a6a436f76cc575b3e3.png)

  ```python
  class InvestRecordPaginateSerializer(BasePaginateSerializer):
      """投资记录列表的分页序列化"""

      def get_object(self, obj):
          return {
              'pId': obj.pId,
              'plan_name': obj.product.productName,
              'invest_amount': float(obj.pAmount),
              "yearRate": float(obj.pEarnings),
              "totalIncome": float(obj.pMonthInterest),
              'month_Income': float(obj.pMonthlyExtractInterest),
              'deal_date': obj.pBeginDate.strftime("%Y-%m-%d"),
              'period': obj.pDeadlineAsDay / 30,
              'status': obj.pStatus
          }
  ```

  - 交易记录序列化

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/eb0c115af37d46e79bbe89e8dc66224f.png)

    ```python
    class DealRecordPaginateSerializer(BasePaginateSerializer):
        """交易记录列表的分页序列化"""

        def get_object(self, obj):
            return {
                'deal_date': obj.aDate.strftime("%Y-%m-%d"),
                'deal_type': obj.aType,
                "descrp": obj.aDescreption,
                "deal_amount": float(obj.aAmount),
                'aAfter_Money': float(obj.aAfterTradingMoney),
                'deal_status': '交易成功' if obj.aTransferStatus else '交易失败'
            }
    ```
  - 投资记录,交易记录资源

    - 投资记录

    transaction包下新建invest_resource.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/1b5b5cde39334ca4a2a68901fbddd7a7.png)

    ```python
    from flask import g
    from flask_restful import Resource
    from flask_restful.reqparse import RequestParser
    from Financial.resources.transaction.serializer import InvestRecordPaginateSerializer
    from comment.models import db
    from comment.models.invest_record import Invest_record

    """
    投资记录
    """


    class Invest(Resource):

        def get(self):
            rp = RequestParser()
            rp.add_argument('start')  # 开始时间
            rp.add_argument('end')  # 结束时间
            rp.add_argument('invest_type')  # 投资类型
            rp.add_argument('curPage')  # 当前页
            rp.add_argument('perPage')  # 每页数量
            args = rp.parse_args()
            start = args.get('start')
            end = args.get('end')
            curPage = int(args.get('curPage'))
            perPage = int(args.get('perPage'))
            invest_type = int(args.get('invest_type'))  # 投资状态

            user_id = g.user_id

            List = Invest_record.query
            # 先按用户id进行筛选，然后用投资状态进行筛选
            filterList = List.filter(Invest_record.pUid == user_id).filter(Invest_record.pStatus == invest_type)

            # 如果有时间段
            if start and end:
                # 根据时间段来筛选
                invest_List = filterList.filter(db.cast(Invest_record.pDate, db.DATE) >= db.cast(start, db.DATE)).filter(
                    db.cast(Invest_record.pDate, db.DATE) <= db.cast(end, db.DATE)).paginate(curPage, perPage,
                                                                                             error_out=False)
            else:
                # 直接分页
                invest_List = filterList.paginate(curPage, perPage, error_out=False)

            data = InvestRecordPaginateSerializer(invest_List).to_dict()
            return {'msg': 'success', 'data': data}

    ```

    - 交易记录

      transaction包下新建 deal_record_resource.py

      ```python
      from flask import g
      from flask_restful import Resource
      from flask_restful.reqparse import RequestParser
      from Financial.resources.transaction.serializer import DealRecordPaginateSerializer
      from comment.models import db

      from comment.models.deal_log import Deal_log
      from comment.models.debt_info import Debt_info
      from comment.models.loanApply import Loan
      from comment.models.user import User


      class Deal_recoard(Resource):

          def get(self):
              rp = RequestParser()
              rp.add_argument('start')  # 开始时间
              rp.add_argument('end')  # 结束时间
              rp.add_argument('deal_type')  # 交易类型
              rp.add_argument('curPage')  # 当前页
              rp.add_argument('perPage')  # 每页数量

              args = rp.parse_args()

              start = args.get('start')
              end = args.get('end')
              deal_type = int(args.get('deal_type'))
              curPage = int(args.get('curPage'))
              perPage = int(args.get('perPage'))

              user_id = g.user_id
              user = User.query.filter(User.id == user_id).first()

              logList = Deal_log.query
              if deal_type > 0:
                  logList = Deal_log.query.filter(Deal_log.aType == deal_type)

              if not user.role:
                  logList = logList.filter(Deal_log.aUserId == user_id)


              if start and end:
                  logList = logList.filter(db.cast(Deal_log.aDate, db.DATE) >= db.cast(start, db.DATE)).filter(
                      db.cast(Deal_log.aDate, db.DATE) <= db.cast(end, db.DATE)).paginate(curPage, perPage, error_out=False)
              else:
                  logList = logList.paginate(curPage, perPage, error_out=False)

              data = DealRecordPaginateSerializer(logList).to_dict()

              return {'msg': 'success', 'data': data}

      ```

##### 7.3 创建蓝图，绑定api资源，注册

tansaction包下init文件（投资记录 交易记录）

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/f3966a134c00424e8f3ef3da72099c78.png)

```python
# 交易模块下的蓝图，包括交易模块的所有资源
from flask import Blueprint
from flask_restful import Api
from comment.utils.output import output_json

transaction_bp = Blueprint('transaction', __name__, url_prefix='/transaction')  # 创建蓝图
transaction_api = Api(transaction_bp)  # 创建蓝图中的资源API

# 使用我们自定义json格式，替代装饰器的写法
transaction_api.representation('application/json')(output_json)

# 加载当前模块的资源

from Financial.resources.transaction.invest_resource import Invest
from Financial.resources.transaction.deal_record_resource import Deal_Record

# 加载当前模块的资源

transaction_api.add_resource(Invest, '/invest_record', endpoint='invest_record')   # 投资记录
transaction_api.add_resource(Deal_Record, '/deal_record', endpoint='deal_record')  # 交易记录

```

product包下新建init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c86e019d66a2440581bf13db188cba74.png)

```python
# 产品模块下的蓝图，包括产品的所有资源
from flask import Blueprint
from flask_restful import Api
from comment.utils.output import output_json

product_bp = Blueprint('product', __name__, url_prefix='/product')  # 创建蓝图
product_api = Api(product_bp)  # 创建蓝图中的资源API

# 使用我们自定义json格式，替代装饰器的写法
product_api.representation('application/json')(output_json)

# 加载当前模块的资源
from Financial.resources.product.product_resource import InvestProduct, ProductRate


product_api.add_resource(InvestProduct, '/proList', endpoint='proList')
product_api.add_resource(ProductRate, '/proRateList', endpoint='proRateList')

```

- 在flask实例上注册蓝图

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/b8d2fef60cd74754829fe23f93eee44b.png)

#### 8.用户资金账户(查询，充值，提现)

##### 8.1 资金账户模型

> 4.2章节已创建好account模型，资金账户是伴随用户的账号创建而同时创建的。

##### 8.2 创建API资源，编写接口

- 创建交易流水号生成器和交易类型枚举类型

  - utils包下新建gen_trans_id.py

    根据传入的交易类型和4位随机数+当前的日期拼接生成流水号

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/fd76e8537c754a56b3fcb730684a91e0.png)
  - 交易类型

    resources包下transaction新建const.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/673ebb3cc3584d338038327ccc55bea4.png)
- resources下新建account包
- 创建账户资源的序列化器，在account包下新建serializer.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/b2f006a74c384434a1df3da3901b6794.png)

  ```python
  from comment.utils.serializers import BaseSerializer


  class AccountInfoSerializer(BaseSerializer):
      """账户序列化"""

      def to_dict(self):
          obj = self.data
          return {
              'total': float(obj.total),  # 账户总额
              "balance": float(obj.balance),  # 账户可用余额
              "profit": float(obj.interestA),  # 已投资总额
              "inverstmentW": float(obj.inverstmentW),  # 总计待收本金
              "interestTotal": float(obj.interestTotal),  # 总计待收利息
              'discount': float(obj.discount)  # 代金券
          }

  ```
- account包下新建account_resource.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/d1130bf0f64a41afbb1b011aa4ae98b4.png)

  ```python
  from flask import g
  from flask_login import login_required, current_user
  from flask_restful import Resource
  from flask_restful.reqparse import RequestParser

  from Financial.resources.transaction.const import DealType
  from comment.models.account import Account
  from Financial.resources.user.serializer import  AccountInfoSerializer
  from comment.models import db
  from comment.models.deal_log import Deal_log
  from comment.utils.gen_trans_id import gen_trans_id


  class AccountInfo(Resource):

      def get(self):
          data = self.get_account_data()
          return data if data else ({'message': '账户不存在'}, 400)


      def get_account_data(self):
          user_id = current_user.id
          acc = Account.query.filter(Account.userId == user_id).first()
          self.accData = {}
          if acc:
              self.accData = AccountInfoSerializer(acc).to_dict()
              return self.accData
          else:
              return None


  class AccountExtract(Resource):
      def post(self):
          rp = RequestParser()
          rp.add_argument('amount', required=True)
          rp.add_argument('card_id', required=True)
          rp.add_argument('payPwd', required=True)

          args = rp.parse_args()
          amount = float(args.amount)
          card_id = args.card_id
          payPwd = args.payPwd
          user = current_user
          user_id = g.user_id

          if not user.check_pay_password(payPwd):
              return {"code": 20001, 'message': '支付密码错误'}

          accountInfo = Account.query.filter(Account.userId == user.id).first()
          if accountInfo:
              if accountInfo.balance< amount:
                  return {'message': 'over Amount'}, 400
              else:
                  beforeAmount = accountInfo.balance
                  accountInfo.balance = float(accountInfo.balance) - amount
                  accountInfo.total = float(accountInfo.total) - amount

                  del_num = gen_trans_id('delnum')
                  # 新增交易记录
                  deal_log = Deal_log(aUserId=user_id, aReceiveOrPay=1, aTransferSerialNo=del_num,
                                      aTransferStatus=1, aBeforeTradingMoney=beforeAmount, aAmount=amount,
                                      aAfterTradingMoney=accountInfo.balance, aDescreption='提现',
                                      aType=DealType.Extract.value)
                  db.session.add(deal_log)
                  db.session.commit()
                  return {'msg': 'success'}
          else:
              return {"code": 20001, 'message': 'server error'}


  class AccountRecharge(Resource):
      def post(self):
          rp = RequestParser()
          rp.add_argument('amount', required=True)
          rp.add_argument('selectedIndex', required=True)

          args = rp.parse_args()
          amount = float(args.amount)
          bangNum = args.selectedIndex
          user = current_user
          user_id = g.user_id

          accountInfo = Account.query.filter(Account.userId == user.id).first()
          if accountInfo:
              beforeAmount = accountInfo.balance
              accountInfo.balance = float(accountInfo.balance) + amount
              accountInfo.total = float(accountInfo.total) + amount

              del_num = gen_trans_id('delnum')
              # 新增交易记录
              deal_log = Deal_log(aUserId=user_id, aReceiveOrPay=0, aTransferSerialNo=del_num,
                                  aTransferStatus=1, aBeforeTradingMoney=beforeAmount, aAmount=amount,
                                  aAfterTradingMoney=accountInfo.balance, aDescreption='充值', aType=DealType.recharge.value)
              db.session.add(deal_log)

              db.session.commit()
              return {'msg': 'success'}
          else:
              return {"code": 20001, 'message': 'server error'}



  ```

##### 8.3 创建蓝图，绑定api资源，注册

account包下创建init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/15b89449f2a24c6892ca4644e6d43dda.png)

```python
# 用户模块下的蓝图，包括用户模块的所有资源

from flask import Blueprint
from flask_restful import Api
from comment.utils.output import output_json

account_bp = Blueprint('account', __name__, url_prefix='/account')  # 创建蓝图
account_api = Api(account_bp)  # 创建蓝图中的资源API

# 在当前用户模块添加请求钩子
# user_bp.before_request()

# 使用我们自定义json格式，替代装饰器的写法
account_api.representation('application/json')(output_json)

# 加载当前模块的资源
from Financial.resources.account.account_resource import AccountInfo, AccountExtract, AccountRecharge


account_api.add_resource(AccountInfo, '/funds', endpoint='funds')
account_api.add_resource(AccountExtract, '/extract', endpoint='extract')
account_api.add_resource(AccountRecharge, '/recharge', endpoint='recharge')
```

- 在flask实例上注册蓝图

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/f0a09dd07bcd4e9fb3be529e7da6fa1a.png)

#### 9.邀请奖励

##### 9.1创建已邀请列表的序列化器

user包下创建 serializer

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/09ce18a1a4a14047b01b83106b3db3ea.png)

```python
class InvitedListSerializer(BaseListSerializer):
    """被邀请列表的序列化"""

    def to_dict(self):
        list = []
        for obj in self.data_list:
            list.append(
                {
                    'name': obj.username,
                    'registerTime': obj.registerTime.strftime("%Y-%m-%d"),
                    "award": '代金券50',
                }
            )
        return list
```

##### 9.2创建API资源，编写接口

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/9760785316bc48fb8b0649970aa8dee9.png)

```python
class Invite(Resource):
    # 设置用户的邀请注册码
    def post(self):
        rp = RequestParser()
        rp.add_argument('code', required=True)
        args = rp.parse_args()
        code = args.code
        u_id = g.user_id
        u = User.query.filter(User.id == u_id).first()
        if u:
            # 设置邀请码
            u.inviteId = code
            db.session.commit()
            return {'msg': 'success', 'invite_code': code}
        else:
            return {"code": 20001, 'message': 'server error'}

    def get(self):
        u_id = g.user_id
        # 查询 邀请人是当前用户的所有人
        invitedList = User.query.filter(User.sumFriends == u_id).all()
        if invitedList:
            data = InvitedListSerializer(invitedList).to_dict()
            return {'msg': 'success', 'list': data}
        else:
            return {"code": 20001, 'list': []}
```

##### 9.3 蓝图上绑定api资源

user包下init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c007037d474c472c817f23ec1a67f791.png)

#### 10.用户账号(查询，实名，支付密码等)

- 添加用户账号信息的序列化器

  user包下serializer

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/f6dc6b0ddb0948e0aeb56457315eadd5.png)

```python
class UserInfoSerializer(BaseSerializer):
    """用户信息序列化"""

    def to_dict(self):
        obj = self.data
        return {
            'id': obj.username,
            "realNameAuth": obj.realNameStatus,
            "phoneStatus": obj.phone,
            'loginPwdstatus': 1,
            "payPwdStatus": obj.payPwdStatus,
            'avatar': obj.avatar,
            'invite_code': obj.remark,
            'phone': obj.phone
        }
```

- user包下user_resource.py

  创建实名认证，实名认证，设置支付密码，修改登录密码，查询用户相信信息的API资源

  ```python
  #     用户头像
  class UserAvatar(Resource):
      def post(self):
          # 获取请求里上传的文件
          imgData = request.files["file"]
          # 获取当前用户
          id = g.user_id
          user = User.query.filter(User.id == id).first()

          # 设置头像存放的路径
          basedir = os.path.abspath(os.path.join(os.getcwd()))
          path = basedir + '/static/avatar/'
          # 设置头像保存的名称和用户id关联
          imgName = str(id) + '_' + imgData.filename

          # 文件保存的完整地址
          file_path = path + imgName

          # 保存文件
          imgData.save(file_path)

          # 保存用户头像名称到数据库
          if user:
              user.avatar = imgName
          db.session.commit()

          return {'msg': 'success', 'avatar': imgName}


  class PayPassword(Resource):
      """
      设置支付密码
      """

      def post(self):
          rp = RequestParser()
          rp.add_argument('pwd', required=True)
          args = rp.parse_args()
          pwd = args.pwd
          id = g.user_id
          user = User.query.filter(User.id == id).first()
          if user:
              user.pay_pwd = pwd
              user.payPwdStatus = 1
              db.session.commit()
              return {'msg': 'success'}
          else:
              return {"code": 20001, 'message': 'server error'}


  class LoginPwd(Resource):
      """
      修改登录密码
      """

      def post(self):
          rp = RequestParser()
          rp.add_argument('orgPwd', required=True)
          rp.add_argument('pwd', required=True)
          args = rp.parse_args()
          pwd = args.pwd
          orgPwd = args.orgPwd
          id = g.user_id
          user = User.query.filter(User.id == id).first()

          if user:
              if user.check_password(orgPwd):
                  user.pwd = pwd
                  db.session.commit()
                  return {'msg': 'success'}
              else:
                  return {'code': 20002, 'message': '原密码不正确'}
          return {"code": 20001, 'message': 'server error'}


  class RealNameAuth(Resource):
      """
      实名认证
      """

      def post(self):
          rp = RequestParser()
          rp.add_argument('realName', required=True)
          rp.add_argument('idNum', required=True)
          args = rp.parse_args()
          realName = args.realName
          idNum = args.idNum
          id = g.user_id
          user = User.query.filter(User.id == id).first()
          status = user.realName
          print(status)
          if user.realName:
              return {"code": 20001, 'message': '不可重复验证'}
          else:
              user.realName = realName  # 名字
              user.realNameStatus = 1  # 实名状态
              user.idNum = idNum  # 身份证
              db.session.commit()
              return {'msg': 'success'}


  class UserInfo(Resource):
      """
      用户信息(包含资金账户)
      """

      def get(self):
          id = g.user_id
          user = User.query.filter(User.id == id).first()
          userInfoData = UserInfoSerializer(user).to_dict()
          acc = Account.query.filter(Account.userId == user.id).first()
          accData = {}
          if acc:
              accData = AccountInfoSerializer(acc).to_dict()

          return {"roles": ["admin"] if user.role else ["user"],
                  "name": user.username,
                  'userInfoData': userInfoData,
                  'accountInfo': accData}
  ```
- 将资源绑定到API上

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/a1f3f5429a5b4181ac71fc70d4afe161.png)

#### 11.借款

##### 11.1创建相关模型

借款涉及到 借款申请，借款申请成功产生的债权，债权匹配成功之后的债权还款，先建立相应的模型。

models包下新建loanApply.py,  debt_info.py,  debt_repay.py

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/abb8f6dd0a2c4ec7877dce48e4cc7350.png)

```python
from sqlalchemy import ForeignKey
from comment.models import db
from datetime import datetime


# 借款申请的模型类
class Loan(db.Model):
    __tablename__ = 't_loan'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True)
    loanNum = db.Column(db.Float(8, 2), doc='借款金额')
    lUid = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户id')
    user = db.relationship('User', backref=db.backref('loanApply', lazy=True))
    duration = db.Column(db.Integer, doc='借款时长')
    lName = db.Column(db.String(64), doc='借款人姓名')
    lRepayType = db.Column(db.Integer, doc='还款模式', default=1)  # 1 等额本金 0 先息后本
    lRate = db.Column(db.Float(4, 2), doc='借款利率')
    lRepayDay = db.Column(db.Integer, doc='还款日', default=10)
    status = db.Column(db.Integer, doc='审批状态', default=0)  # 0未审批 1通过 2驳回
    applyDate = db.Column(db.DateTime, default=datetime.now(), doc='申请时间')



```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/14b618e76f104ab0a49f44d45fb390cd.png)

```python
from sqlalchemy import ForeignKey
from comment.models import db


# 债权表的模型类
class Debt_info(db.Model):
    __tablename__ = 't_debt_info'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True)
    debtNo = db.Column(db.String(128), doc='债权编号')
    loanNo = db.Column(db.BIGINT, ForeignKey('t_loan.id'), doc='借款id')
    loanApply = db.relationship('Loan', backref=db.backref('debt_info', lazy=True, uselist=False))
    debtorsName = db.Column(db.String(64), doc='债务人名称')
    debtorsId = db.Column(db.String(128), doc='债务人身份证号')
    loanPurpose = db.Column(db.String(128), doc='借款用途')
    loanType = db.Column(db.Integer, doc='借款类型')
    loanStartDate = db.Column(db.DateTime, doc='原始借款开始日期')
    loanPeriod = db.Column(db.Integer, doc='原始借款期限')
    loanEndDate = db.Column(db.Date, doc='原始借款到期日期')
    repaymentStyle = db.Column(db.Integer, doc='还款方式')
    repaymenDate = db.Column(db.Integer, doc='还款日')
    repaymenMoney = db.Column(db.Float(8, 2), doc='还款金额')
    debtMoney = db.Column(db.Float(8, 2), doc='债权金额')
    debtYearRate = db.Column(db.Float(4, 2), doc='债权年化利率')
    debtMonthRate = db.Column(db.Float(4, 2), doc='债权月利率')
    debtTransferredMoney = db.Column(db.Float(8, 2), doc='债权转入金额')
    debtTransferredDate = db.Column(db.Date, doc='债权转入日期')
    debtTransferredPeriod = db.Column(db.Date, doc='债权转入期限')
    debtRansferOutDate = db.Column(db.Date, doc='债权转出日期')
    creditor = db.Column(db.String(64), doc='债权人')
    debtStatus = db.Column(db.Integer, doc='债权状态')
    borrowerId = db.Column(db.BIGINT, ForeignKey('t_user.id'),doc='借款人ID')
    user = db.relationship('User', backref=db.backref('debt_info', lazy=True))
    availablePeriod = db.Column(db.Date, doc='可用期限')
    availablePeriod = db.Column(db.Integer, doc='可用金额')
    matchedMoney = db.Column(db.Float(8, 2), doc='已匹配金额')
    matchedStatus = db.Column(db.Integer, doc='匹配状态')  # 0 未匹配  1 部分匹配  2 完全匹配
    repaymentStyleName = db.Column(db.String(64), doc='还款方式名称')
    debtStatusName = db.Column(db.String(64), doc='债权状态名字')
    matchedStatusName = db.Column(db.String(64), doc='匹配状态名称')
    debtType = db.Column(db.Integer, doc='标的类型')
    debtTypeName = db.Column(db.String(64), doc='标的类型名称')
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/4b0575e9c787431fa87829ecf3b18df3.png)

```
from comment.models import db
from sqlalchemy import ForeignKey


# 债权还款的模型类
class Debtor_repay(db.Model):
    __tablename__ = 't_debtor_record'
    id = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='主键')
    claimsId = db.Column(db.BIGINT, ForeignKey('t_debt_info.id'), doc='债权id')
    debtInfo = db.relationship('Debt_info', backref=db.backref('debtor_record', lazy=True))
    receivableDate = db.Column(db.DateTime, doc='应还日期')
    receivableMoney = db.Column(db.Float(8, 2), doc='应还余额')
    currentTerm = db.Column(db.Integer, doc='当前还款期')
    recordDate = db.Column(db.DateTime, doc='记录日期')
    isReturned = db.Column(db.Integer, default=0, doc='是否还款')  # 0未还款 1已还款
```

##### 11.2 创建API资源，编写接口

- 在transaction包下的serializer.py，创建借款资源相关的序列化器

  ```python
  class DebtPaginateSerializer(BasePaginateSerializer):
      """债权的分页序列化"""

      def get_object(self, obj):
          return {
              'debtNo': obj.debtNo,
              'loanNo': obj.loanNo,
              "loanStartDate": obj.loanStartDate.strftime("%Y-%m-%d"),
              "repaymenDate": obj.repaymenDate,
              'debtYearRate': float(obj.debtYearRate),
              'debtMoney': float(obj.debtMoney),
              'debtOriginalMoney': float(obj.debtTransferredMoney),
              'matchedStatus': obj.matchedStatus,
              'matchedMoney': float(obj.matchedMoney),
              'debtStatus': obj.matchedStatus,
          }




  class LoanPaginateSerializer(BasePaginateSerializer):
      """ 借款列表分页序列化"""

      def get_object(self, obj):
          return {
              'loanApplyId': obj.id,
              'name': obj.lName,
              "applyTime": obj.applyDate.strftime("%Y-%m-%d %H:%M:%S"),
              "amount": float(obj.loanNum),
              'duration': obj.duration,
              'loanRate': float(obj.lRate),
              'repayDay': obj.lRepayDay,
              'repayType': obj.lRepayType,
              'status': obj.status,
              'debt_match_status': obj.debt_info.matchedStatus if obj.debt_info else '',
              'debt_id': obj.debt_info.id if obj.debt_info else '',

          }


  class RepayPlanSerializer(BaseListSerializer):
      """还款计划的序列化"""

      def to_dict(self):
          list = []
          for obj in self.data_list:
              list.append(
                  {
                      'id': obj.id,
                      'currentTerm': obj.currentTerm,
                      'receivableDate': obj.receivableDate.strftime("%Y-%m-%d"),
                      "receivableMoney": float(obj.receivableMoney),
                      'isReturned': obj.isReturned,
                  }
              )
          return list
  ```
- 创建借款相关的资源

  - 债权资源 transaction包下 新建debt_resource.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c8327ddb138743ffba3d22f6c45beb3e.png)

    ```python
    from flask_restful import Resource
    from flask_restful.reqparse import RequestParser
    from Financial.resources.transaction.serializer import DebtPaginateSerializer
    from comment.models import db
    from comment.models.debt_info import Debt_info


    # 债权
    class Debt(Resource):

        def get(self):
            rp = RequestParser()
            rp.add_argument('start')  # 借款人
            rp.add_argument('end')  # 借款人
            rp.add_argument('curPage')  # 当前页
            rp.add_argument('perPage')  # 每页数量

            args = rp.parse_args()

            curPage = int(args.get('curPage'))
            perPage = int(args.get('perPage'))
            start = args.get('start')
            end = args.get('end')

            debtList = Debt_info.query

            if start and end:
                # 如果有筛选时间
                debtList = debtList.filter(db.cast(Debt_info.loanStartDate, db.DATE) >= db.cast(start, db.DATE)).filter(
                    db.cast(Debt_info.loanStartDate, db.DATE) <= db.cast(end, db.DATE)).paginate(curPage, perPage, error_out=False)
            else:
                debtList = debtList.paginate(curPage, perPage, error_out=False)
                # 将分页结果序列化
            data = DebtPaginateSerializer(debtList).to_dict()

            return {'msg': 'success', 'data': data}



    ```
  - 债权还款  transaction包下 新建debt_repay_resource.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/7be09ce8f38b411783dcb61fa7181bd7.png)

    ```python
    from datetime import datetime
    from flask import g
    from flask_restful import Resource
    from flask_restful.reqparse import RequestParser
    from Financial.resources.transaction.serializer import RepayPlanSerializer
    from comment.models import db
    from comment.models.debt_repay import Debtor_repay
    from comment.models.user import User

    # 还款计划
    class RepayPlan(Resource):

        # 查询指定债权的还款计划列表
        def get(self):
            rp = RequestParser()
            rp.add_argument('debt_id')
            args = rp.parse_args()
            debt_id = int(args.get('debt_id'))
            repayList = Debtor_repay.query.filter(Debtor_repay.claimsId == debt_id)
            data = RepayPlanSerializer(repayList).to_dict()

            return {'msg': 'success', 'data': data}

        # 还款到指定还款计划
        def post(self):
            rp = RequestParser()
            rp.add_argument('repay_id')
            rp.add_argument('repayAmount')
            args = rp.parse_args()
            repay_id = int(args.get('repay_id'))
            repay_money = float(args.get('repayAmount'))

            user_id = g.user_id

            user = User.query.filter(User.id == user_id).first()
            # 判断余额是否足够还款
            if float(user.accountInfo.balance) < repay_money:
                return {'message': '可用余额不足', 'code': 20005}
            else:
                # 扣除余额
                user.accountInfo.balance = float(user.accountInfo.balance) - repay_money
                repayDetail = Debtor_repay.query.filter(Debtor_repay.id == repay_id).first()
                # 更改还款状态
                repayDetail.isReturned = 1
                # 记录日期
                repayDetail.recordDate = datetime.now()
                db.session.commit()
                return {'msg': 'success'}

    ```
  - 债权还款  transaction包下 新建loan_resource.py

    ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/a1ce328751ba4c9188b1616e84308a0a.png)

    ```python
    from datetime import datetime, timedelta
    from flask import current_app, g
    from flask_restful import Resource
    from flask_restful.reqparse import RequestParser
    from Financial.resources.transaction.const import LoanConfig
    from Financial.resources.transaction.serializer import LoanPaginateSerializer
    from comment.models import db
    from comment.models.debt_info import Debt_info
    from comment.models.debt_repay import Debtor_repay
    from comment.models.loanApply import Loan
    from comment.models.user import User
    from comment.utils.financial_redis import redis_client
    from comment.utils.gen_trans_id import gen_trans_id, decimal_truncation


    # 借款
    class LoanApply(Resource):

        # 借款申请
        def post(self):
            rp = RequestParser()
            rp.add_argument('holder', required=True)  # 借款人
            rp.add_argument('amount', required=True)  # 金额
            rp.add_argument('code', required=True)  # 电话
            rp.add_argument('loanMonth', required=True)  # 借款期数

            user_id = g.user_id
            cur_user = User.query.filter(User.id == user_id).first()
            args = rp.parse_args()
            amount = args.amount
            loan_month = args.loanMonth
            code = args.code
            username = cur_user.username

            key = 'registerCode:{}'.format(cur_user.phone)
            try:
                real_code = redis_client.get(key)  # 从redis中返回的是字节数据
            except ConnectionError as e:
                current_app.logger.error(e)
                return {"code": 20001, 'message': 'redis db connect error.'}
            # 开始校验
            if not real_code or real_code.decode() != code:
                return {'message': '验证码错误或已失效'}, 400

            # 创建借款记录
            apply = Loan(loanNum=amount, lUid=user_id, duration=loan_month, lName=username, lRate=5.5, lRepayDay=10)
            db.session.add(apply)
            db.session.commit()
            return {'msg': 'success'}

        # 获取借款列表
        def get(self):
            rp = RequestParser()
            rp.add_argument('start')  # 开始时间
            rp.add_argument('end')  # 结束时间
            rp.add_argument('curPage')  # 当前页
            rp.add_argument('perPage')  # 每页数量
            rp.add_argument('approve_status')  # 每页数量

            args = rp.parse_args()
            start = args.get('start')
            end = args.get('end')
            curPage = int(args.get('curPage'))
            perPage = int(args.get('perPage'))
            status = int(args.get('approve_status'))
            # 根据status审批状态来筛选
            applyList = Loan.query.filter(Loan.status == status)
            if start and end:
                # 如果有时间筛选
                applyList = applyList.filter(db.cast(Loan.applyDate, db.DATE) >= db.cast(start, db.DATE)).filter(
                    db.cast(Loan.applyDate, db.DATE) <= db.cast(end, db.DATE)).paginate(curPage, perPage, error_out=False)
            else:
                applyList = applyList.paginate(curPage, perPage, error_out=False)
            # 分页序列化
            data = LoanPaginateSerializer(applyList).to_dict()

            return {'msg': 'success', 'data': data}

        # 审批借款
        def put(self):
            rp = RequestParser()
            rp.add_argument('applyId')  # 借款人
            rp.add_argument('status')  # 借款人
            args = rp.parse_args()
            applyId = args.get('applyId')
            status = args.get('status')
            apply = Loan.query.filter(Loan.id == applyId)
            # 更新借款的审批状态
            apply.update({'status': status})
            db.session.commit()
            #  审批通过 status == '1'
            if status == '1':
                applyData = apply.first()
                debtNo = gen_trans_id('debt')
                contractNo = gen_trans_id('cstc')
                debtorsId = applyData.user.idNum
                endDate = datetime.now() - timedelta(days=applyData.duration * 30)
                # 创建债权
                newDebt = Debt_info(debtNo=debtNo, debtorsName=applyData.lName, loanNo=applyId,
                                    debtorsId=debtorsId, loanStartDate=datetime.now(), loanPeriod=applyData.duration,
                                    loanEndDate=endDate, repaymentStyle=applyData.lRepayType, matchedMoney=0,
                                    repaymenDate=applyData.lRepayDay, repaymenMoney=applyData.loanNum, matchedStatus=0,
                                    debtMoney=applyData.loanNum, debtYearRate=applyData.lRate, debtTransferredMoney=0)
                db.session.add(newDebt)
                db.session.flush()
                # 创建还款计划
                self.createRepayPlay(newDebt)
                db.session.commit()

            return {'msg': 'success'}

        # 创建还款计划
        def createRepayPlay(self, newDebt):

            # 月还款金额
            monthCost = decimal_truncation(newDebt.repaymenMoney / newDebt.loanPeriod, 2)
            # 月利率
            monthRate = decimal_truncation(LoanConfig.YEAR_RATE.value / 12, 4)
            for m in range(1, newDebt.loanPeriod + 1):
                # 每月应还利息
                interest = decimal_truncation((float(newDebt.repaymenMoney) - float(monthCost) * (m - 1)) * monthRate, 2)
                # 每月应还总金额
                total = decimal_truncation(float(monthCost) + interest, 2)
                # 生成还款计划
                repayPlan = Debtor_repay(claimsId=newDebt.id, receivableMoney=total,
                                          currentTerm=m, recordDate=datetime.now())
                db.session.add(repayPlan)


    # 我的借款
    class MyLoan(Resource):
        def get(self):
            rp = RequestParser()
            rp.add_argument('curPage')  # 当前页
            rp.add_argument('perPage')  # 每页数量
            args = rp.parse_args()
            curPage = int(args.get('curPage'))
            perPage = int(args.get('perPage'))
            user_id = g.user_id
            loanList = Loan.query.filter(Loan.lUid == user_id).paginate(curPage, perPage, error_out=False)

            data = LoanPaginateSerializer(loanList).to_dict()

            return {'msg': 'success', 'data': data}

    ```

##### 11.3 蓝图绑定API资源

transaction包下的init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/ad7bdb87647c48a2854269fda3fded29.png)

```python
# 交易模块下的蓝图，包括交易模块的所有资源
from flask import Blueprint
from flask_restful import Api
from comment.utils.output import output_json

transaction_bp = Blueprint('transaction', __name__, url_prefix='/transaction')  # 创建蓝图
transaction_api = Api(transaction_bp)  # 创建蓝图中的资源API

# 使用我们自定义json格式，替代装饰器的写法
transaction_api.representation('application/json')(output_json)

# 加载当前模块的资源

from Financial.resources.transaction.invest_resource import Invest
from Financial.resources.transaction.deal_record_resource import Deal_Record
from Financial.resources.transaction.loan_resource import LoanApply
from Financial.resources.transaction.debt_resource import Debt
from Financial.resources.transaction.loan_resource import MyLoan
from Financial.resources.transaction.debt_repay_resource import RepayPlan

# 加载当前模块的资源

transaction_api.add_resource(Invest, '/invest_record', endpoint='invest_record')   # 投资记录
transaction_api.add_resource(Deal_Record, '/deal_record', endpoint='deal_record')  # 交易记录
transaction_api.add_resource(LoanApply, '/loanApply', endpoint='loanApply')  # 借款申请
transaction_api.add_resource(MyLoan, '/myLoan', endpoint='myLoan')  # 我的借款
transaction_api.add_resource(Debt, '/debt', endpoint='debt')    # 债权
transaction_api.add_resource(RepayPlan, '/RepayPlan', endpoint='RepayPlan')  # 还款计划

```

#### 12.投资(理财购买)

##### 12.1创建模型

- models下新建expected_return.py （预期收益）

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/2cdbade6cab7463e8742ffa88e93bd2e.png)

```python
from datetime import datetime
from sqlalchemy import ForeignKey
from comment.models import db


# 预期收益表的模型类
class Expected_return(db.Model):
    __tablename__ = 't_expected_return'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    userId = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户ID')
    productId = db.Column(db.BIGINT, ForeignKey('t_product.proId'), doc='产品ID')
    investRecord = db.Column(db.BIGINT, ForeignKey('t_invest_record.pId'), doc='投资记录ID')
    expectedDate = db.Column(db.DateTime, doc='收益日期')
    expectedMoney = db.Column(db.Float(8, 2), doc='收益金额', default=0)
    createDate = db.Column(db.DateTime, default=datetime.now(), doc='创建日期')
```

- funding_not_matched.py(待匹配资金)

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/c37ca1c7e08a43fa80840a9428dbfe1b.png)

  ```python
  from sqlalchemy import ForeignKey
  from comment.models import db


  # 待匹配资金表的模型类
  class Funding_not_matched(db.Model):
      __tablename__ = 't_funding_not_matched'
      fId = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='主键')
      fInvestRecordId = db.Column(db.BIGINT, ForeignKey('t_invest_record.pId'), doc='投资记录')
      investRecord = db.relationship('Invest_record', backref=db.backref('fundsNotMatched', lazy=True))
      fNotMatchedMoney = db.Column(db.Float(8, 2), doc='待匹配金额')
      fFoundingType = db.Column(db.Integer, doc='资金类型', default=1)
      fFoundingWeight = db.Column(db.Float(8, 2), doc='资金')
      matchedStatus = db.Column(db.Integer, doc='匹配状态')  # 0 未匹配  1 部分匹配  2 完全匹配
      fCreateDate = db.Column(db.DateTime, doc='创建时间', default=0)
  ```

##### 12.2 创建API资源，编写接口

transaction包 invest_resource.py

invest资源下添加post方法（购买理财）

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/d9f0413bb1ae4dd290523c00eea1c1a2.png)

```python
    def post(self):
        rp = RequestParser()
        rp.add_argument('productId', required=True)  # 产品ID
        rp.add_argument('pAmount', required=True)  # 金额
        rp.add_argument('period', required=True)  # 期数
        args = rp.parse_args()
        productId = int(args.productId)+1  # 产品id
        pAmount = int(args.pAmount)        # 购买金额
        period = int(args.period)          # 购买期数

        user_id = g.user_id
        # 理财产品
        product = Product.query.filter(Product.proId == productId).first()
        user = User.query.filter(User.id == user_id).first()

        # 当前选择的理财产品对应期数的利率对象
        proRate = Product_rate.query.filter(Product_rate.productId == productId).filter(Product_rate.month == period).\
            first()

        # 单期收益
        income = self.calculat_income(proRate.incomeRate, pAmount)

        # 生成交易流水号
        investNum = gen_trans_id('tznum')
        # 投资到期日期
        pEndDate = datetime.now() + timedelta(days=period * 30)

                try:
            user_account = Account.query.filter(Account.userId == user_id)
            #  更新用户资产
            cur_discount = 50 if user_account.first().discount >= 50 else 0
            _pAmount = pAmount - cur_discount
            if user_account.first().balance >= _pAmount:
                beforeBalance = user_account.first().balance
                cur_blance = user_account.first().balance - _pAmount
                discount = user_account.first().discount - cur_discount
            else:
                return {'message': '可用余额不足', 'code': 20005}

            interestTotal = income * period
            inverstmentW = user_account.first().inverstmentW + pAmount
            frozen = user_account.first().frozen + pAmount
            user_account.update({'balance': cur_blance, 'inverstmentA': Account.inverstmentA+pAmount, "frozen": frozen,
                                 'interestTotal': Account.interestTotal+interestTotal, "inverstmentW": inverstmentW,
                                 'discount': discount})
            # 新增投资记录
            _pRemark = '使用了50元代金券' if cur_discount == 50 else ''
            investRecord = Invest_record(pProductId=productId, pUid=user_id, pBeginDate=datetime.now(),
                                         pEndDate=pEndDate, pSerialNo=investNum, pAmount=pAmount,
                                         pEarnings=proRate.incomeRate,
                                         pDeadline=period, pMonthInterest=income,
                                         pMonthlyExtractInterest=income,
                                         pAvailableBalance=user.accountInfo.balance,
                                         pFrozenMoney=pAmount, pProductName=product.productName,
                                         pDeadlineAsDay=period * 30, username=user.username,
                                         pProspectiveEarnings=interestTotal, pStatus=0, pRemark=_pRemark
                                         )
            db.session.add(investRecord)
            db.session.flush()
            # 新增待匹配资金
            fundingNotMatched = Funding_not_matched(fInvestRecordId=investRecord.pId, fNotMatchedMoney=pAmount,
                                                    fFoundingWeight=1, matchedStatus=0)
            db.session.add(fundingNotMatched)

            del_num = gen_trans_id('delnum')
            # 新增交易记录
            deal_recprd = DealRecord(aUserId=user_id, pId=investRecord.pId, aReceiveOrPay=1, aTransferSerialNo=del_num,
                                aTransferStatus=1, aBeforeTradingMoney=beforeBalance, aAmount=pAmount,
                                aAfterTradingMoney=cur_blance, aDescreption='投资产品购买', aType=DealType.invest.value)
            db.session.add(deal_recprd)
            db.session.commit()
            return {'msg': 'success', 'data': 'data'}
        except Exception as e:
            print(e)
            db.session.rollback()

    # 计算收益
    def calculat_income(self, rate, amount):
        temNum = (rate / 100 / 12) * 1000000
        _index = str(temNum).find(".")
        temNum = int(str(temNum)[0:_index]) / 1000000
        return decimal_truncation((amount * temNum), 2)
```

##### 12.3 蓝图绑定api资源

transaction包下init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/588f1f0f3e6c46a893d94fc5bba973b8.png)

```python
transaction_api.add_resource(Invest, '/invest', endpoint='invest')  # 投资(购买理财产品)
```

#### 13.撮合匹配

撮合流程梳理：

> 借款人申请借款，借款成功之后，会产生一笔债权记录。
>
> 投资人购买了投资产品，会产生一笔待匹配资金。
>
> 撮合匹配的功能就是将债权和投资资金进行匹配，单笔债权或资金完全匹配后，开始产生利息/收益。
>
> 债权匹配成功后，会开启债权生成时候一并生成的还款计划。还款计划开启日期为匹配成功日期。
>
> 待匹配资金匹配成功后，会产生预期收益表，从匹配成功日期开始计算投资时间，投资期限到期可以提取本金和收益

##### 13.1创建模型

- 匹配结果

  models包下新建matched_result.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/d619b15a471e414da85d70c4db9fec53.png)

  ```
  from sqlalchemy import ForeignKey
  from comment.models import db


  # 匹配结果表的模型类
  class Matched_result(db.Model):
      __tablename__ = 't_matched_result'
      id = db.Column(db.BIGINT, primary_key=True, autoincrement=True, doc='主键')
      userId = db.Column(db.BIGINT, ForeignKey('t_user.id'), doc='用户id')
      user = db.relationship('User', backref=db.backref('matched_result', lazy=True))
      debtId = db.Column(db.BIGINT, ForeignKey('t_debt_info.id'), doc='债权id')
      debt_info = db.relationship('Debt_info', backref=db.backref('matched_result', lazy=True))
      investId = db.Column(db.BIGINT, ForeignKey('t_invest_record.pId'), doc='投资记录主键')
      investRecord = db.relationship('Invest_record', backref=db.backref('matched_result', lazy=True))
      transferSerialNo = db.Column(db.String(100), doc='交易流水号')
      purchaseMoney = db.Column(db.Float(8, 2), doc='购买金额（匹配金额）', default=0)
      confirmedDate = db.Column(db.DateTime, doc='购买日期（匹配日期）')
      isConfirmed = db.Column(db.Integer, doc='是否确认', default=0)
      matchDate = db.Column(db.DateTime, doc='匹配上的日期', default=3)
      fundType = db.Column(db.Integer, doc='资金类型')
      debtType = db.Column(db.Integer, doc='债权类型')
      isExecuted = db.Column(db.Integer, doc='是否清算过')
  ```

##### 13.2 撮合债权与资金

- 由于撮合成功之后，我们要开启还款计划的时间以及生成预期收益表，都是以当前日期为起点，往后的每个月的当日或者N个月后的当日。为了方便计算日期，我们安装一个日期工具包。python-dateutil

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/8c21226bcb424889ab9441a5a4531e64.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/10229158938b4750a342209f41a29edf.png)

```
终端输入
pip install python-dateutil
```

- tansaction包下 新建match_resource.py

  ```python
  from collections import deque
  from datetime import datetime
  from sqlalchemy import or_
  from flask_restful import Resource
  from dateutil.relativedelta import *
  from comment.models import db
  from comment.models.debt_info import Debt_info
  from comment.models.expected_return import Expected_return
  from comment.models.funding_not_matched import Funding_not_matched
  from comment.models.matched_result import Matched_result
  from comment.utils.gen_trans_id import gen_trans_id

  """ 撮合匹配 """


  # 队列对象
  class MathcQueqe():
      # 初始化队列
      def __init__(self, item_list):
          self.items = deque(item_list)

      # 从队列头取一个元素
      def getLeft(self):
          return self.items.popleft()

      # 将元素放回队列头
      def push(self, item):
          return self.items.appendleft(item)

      # 判断队列是否为空
      @property
      def empty(self):
          return len(self.items) == 0


  # 开始匹配
  class Match:
      def __init__(self):
          # 未匹配或部分匹配债权列表
          debt_list = Debt_info.query.filter \
              (or_(Debt_info.matchedStatus == 0, Debt_info.matchedStatus == 1)).all()
          # 未匹配或部分匹配资金列表
          fund_list = Funding_not_matched.query.filter \
              (or_(Funding_not_matched.matchedStatus == 0, Funding_not_matched.matchedStatus == 1)).all()
          # 债权队列
          self.debtDeque = MathcQueqe(debt_list)
          # 资金队列
          self.fundsDeque = MathcQueqe(fund_list)

      def startMatch(self):

          try:
              while (not self.fundsDeque.empty) and (not self.debtDeque.empty):
                  debtItem = self.debtDeque.getLeft()
                  fundItem = self.fundsDeque.getLeft()
                  print('当前匹配的债权金额', debtItem.debtMoney, '----', '当前匹配的资金金额', fundItem.fNotMatchedMoney)
                  if debtItem.debtMoney > fundItem.fNotMatchedMoney:
                      self.debtMoreThanfunds(debtItem, fundItem)
                  elif debtItem.debtMoney < fundItem.fNotMatchedMoney:
                      self.debtLessThanfunds(debtItem, fundItem)
                  else:
                      self.debtEqualfunds(debtItem, fundItem)
              db.session.commit()
              return {'msg': '匹配完成'}
          except Exception as e:
              print(e)
              db.session.rollback()
              return {'message': '服务器忙, 请稍后重试'}, 500

      # 待匹配的债权 大于 待匹配资金
      def debtMoreThanfunds(self, debt, funds):
          self.createMatchedResult(debt, funds, funds.fNotMatchedMoney)
          debt.debtMoney -= funds.fNotMatchedMoney  # 债权未匹配金额
          debt.matchedStatus = 1  # 债权匹配状态 0未匹配 1部分 2完全匹配
          debt.matchedMoney += funds.fNotMatchedMoney  # 债权已匹配金额
          funds.fNotMatchedMoney = 0
          funds.matchedStatus = 2
          self.debtDeque.push(debt)  # 债权金额大于资金金额，重新放回队列
          self.createExpectedReturn(funds)

      # 待匹配的债权 小于 待匹配资金
      def debtLessThanfunds(self, debt, funds):
          funds.fNotMatchedMoney -= debt.debtMoney  # 资金未匹配金额
          funds.matchedStatus = 1
          debt.matchedMoney += debt.debtMoney  # 债权已匹配金额
          self.createMatchedResult(debt, funds, debt.debtMoney)
          debt.debtMoney = 0  # 债权未匹配金额
          debt.user.accountInfo.balance += debt.repaymenMoney
          debt.matchedStatus = 2  # 债权匹配状态 0未匹配 1部分 2完全匹配
          self.startRepayPlay(debt)
          self.fundsDeque.push(funds)

      # 待匹配的债权 等于于 待匹配资金
      def debtEqualfunds(self, debt, funds):
          debt.matchedStatus = 2  # 债权匹配状态 0未匹配 1部分 2完全匹配
          debt.matchedMoney += funds.fNotMatchedMoney  # 债权已匹配金额
          self.createMatchedResult(debt, funds, debt.debtMoney)
          debt.debtMoney = 0  # 债权未匹配金额
          funds.fNotMatchedMoney = 0
          funds.matchedStatus = 2
          self.createExpectedReturn(funds)
          self.startRepayPlay(debt)

      # 创建预期收益
      def createExpectedReturn(self, funds):
          ex_return = Expected_return(userId=funds.investRecord.pUid, productId=funds.investRecord.pProductId,
                                      investRecord=funds.investRecord.pId,
                                      expectedDate=datetime.now() + relativedelta(months=funds.investRecord.pDeadline),
                                      expectedMoney=funds.investRecord.pProspectiveEarnings)
          funds.investRecord.pStatus = 1
          db.session.add(ex_return)

      # 生成匹配结果
      def createMatchedResult(self, debt, funds, amount):
          match_num = gen_trans_id('matctnum')
          result = Matched_result(userId=funds.investRecord.pUid, debtId=debt.id, investId=funds.investRecord.pId,
                                  transferSerialNo=match_num, purchaseMoney=amount,
                                  confirmedDate=funds.investRecord.pDate,
                                  isConfirmed=1, matchDate=datetime.now())
          db.session.add(result)

      # 债权还款时间开始生效
      def startRepayPlay(self, debt):
          # 还款计划
          repayPlan = debt.debtor_record
          for i in range(len(repayPlan)):
              repayDate = datetime.now() + relativedelta(months=(i + 1))
              # 还款计划的还款时间根据期数 按月增加
              repayPlan[i].receivableDate = repayDate


  class MatchUp(Resource):

      def post(self):
          match = Match()
          return match.startMatch()

  ```

##### 13.3 蓝图绑定api资源

transaction包下init文件

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/e2ad5444ed2a49bf93a121990e771137.png)

```python
transaction_api.add_resource(MatchUp, '/matchUp', endpoint='matchUp')   # 撮合匹配
```

#### 14.未匹配资金/预期收益/提取收益/匹配结果

##### 14.1 匹配资金列表

- 创建匹配资金的序列化器

  tansaction包下serializer.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/fc4f176b31db4313b8acdf7f034f3516.png)

```python
class FoundsNotMatchedPaginateSerializer(BasePaginateSerializer):
    """未匹配资金的分页序列化"""

    def get_object(self, obj):
        return {
            'weigh': 0,
            'username': obj.investRecord.user.username,
            "InvestRecordNum": obj.investRecord.pSerialNo,
            "productName": obj.investRecord.product.productName,
            'investDate': obj.investRecord.pDate.strftime("%Y-%m-%d"),
            'period': obj.investRecord.pDeadlineAsDay / 30,
            'notMatchedMoney': float(obj.fNotMatchedMoney),
            'matchStatus': obj.matchedStatus,
        }
```

- 未匹配资金的API资源

  tansaction包下新建foundingNotMatched_resource.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/236a68cfccec4c7ead58c785b7724651.png)

  ```python
  from flask_restful import Resource
  from flask_restful.reqparse import RequestParser
  from Financial.resources.transaction.serializer import FoundsNotMatchedPaginateSerializer
  from comment.models.funding_not_matched import Funding_not_matched


  class FoundingNotMatched(Resource):
      # 未匹配资金
      def get(self):
          rp = RequestParser()
          rp.add_argument('curPage')  # 当前页
          rp.add_argument('perPage')  # 每页数量
          rp.add_argument('type')     # 匹配状态

          args = rp.parse_args()

          curPage = int(args.get('curPage'))
          perPage = int(args.get('perPage'))
          type = int(args.get('type'))
          if not type:
              # 未匹配和部分比配的
              fundsList = Funding_not_matched.query.filter(Funding_not_matched.matchedStatus != 2)
          else:
              # 完全匹配的
              fundsList = Funding_not_matched.query.filter(Funding_not_matched.matchedStatus == 2)

          fundsList = fundsList.paginate(curPage, perPage, error_out=False)
          # 序列化匹配资金
          data = FoundsNotMatchedPaginateSerializer(fundsList).to_dict()

          return {'msg': 'success', 'data': data}



  ```

##### 14.2 预期收益

- 创建续期收益的序列化器

  tansaction包下serializer.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/04c8283024944fb29749ce5826eb7dd0.png)

  ```python
  class ExpectedReturnPaginateSerializer(BasePaginateSerializer):
      """预期收益表的分页序列化"""

      def get_object(self, obj):
          return {
              'return_id': obj.id,
              'userId': obj.userId,
              'productId': obj.productId,
              "investRcordID": obj.investRecord,
              "expectedDate": obj.expectedDate.strftime("%Y-%m-%d"),
              # date 日期的 时间戳
              'expectedStamp': datetime.timestamp(datetime(obj.expectedDate.date().year, obj.expectedDate.date().month,
                                                           obj.expectedDate.date().day)),
              'return_Money': float(obj.expectedMoney),

          }
  ```
- 预期收益的API资源

  tansaction包下新建foundingNotMatched_resource.py

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/7708184008084487a9e84d4cffee8c31.png)

##### 14.3 提取收益

transaction包下新建investIncome_resource.py

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/715a96caad454998926df20fc0c47652.png)

```python
from flask import g
from flask_restful import Resource
from flask_restful.reqparse import RequestParser
from datetime import datetime
from Financial.resources.transaction.const import DealType
from comment.models import db
from comment.models.account import Account
from comment.models.deal_record import DealRecord
from comment.models.expected_return import Expected_return
from comment.models.invest_record import Invest_record
from comment.utils.gen_trans_id import gen_trans_id


class InvestIncome(Resource):

    # 提取收益
    def post(self):
        rp = RequestParser()
        rp.add_argument('return_id')  # 开始时间
        args = rp.parse_args()
        return_id = int(args.get('return_id'))

        user_id = g.user_id
        # 查询当前用户的资金账户
        account = Account.query.filter(Account.userId == user_id).first()
        # 查询当前预期收益id的这条记录
        return_income = Expected_return.query.filter(Expected_return.id == return_id).first()

        if return_income:
            cur_date = datetime.now().date()
            expectedDate = return_income.expectedDate.date()
            # 如果当前日期大于投资到期日期
            if cur_date >= expectedDate:
                try:
                    # 生成交易流水号
                    del_num = gen_trans_id('delnum')
                    # 生成交易记录
                    deal_log = DealRecord(aUserId=user_id, aReceiveOrPay=1, aTransferSerialNo=del_num,
                                        aTransferStatus=1, aBeforeTradingMoney=account.balance,
                                        aAmount=return_income.expectedMoney,aAfterTradingMoney=account.balance,
                                        aDescreption='提取收益', aType=DealType.income.value)
                    db.session.add(deal_log)
                    # 账户投资收益增加
                    account.interestA += return_income.expectedMoney
                    # 获取预期收益对应的投资记录
                    invest = Invest_record.query.filter(Invest_record.pId == return_income.investRecord).first()
                    # 更改投资状态
                    invest.pStatus = 2
                    # 账户可用余额返还投资金额
                    account.balance += invest.pAmount
                    # 账户冻结金额释放
                    account.frozen -= invest.pAmount
                    # 预期收益清空
                    return_income.expectedMoney = 0
                    db.session.commit()
                    return {'msg': 'success'}
                except Exception as e:
                    print(e)
                    db.session.rollback()
            else:
                return {"message": '投资未到期', 'code': 20001}
        else:
            return {'message': '未找到资源'}, 401
```

##### 14.5 匹配结果

- 创建匹配结果的序列化器

  tansaction包下serializer.py

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/bbf9e16771c74d90b6e70f13774ce0b0.png)

```python
class MatchedResultPaginateSerializer(BasePaginateSerializer):
    """ 匹配结果分页 序列化"""

    def get_object(self, obj):
        return {
            'userId': obj.userId,
            'debtId': obj.debtId,
            "investId": obj.investId,
            "transNo": obj.transferSerialNo,
            'Money': float(obj.purchaseMoney),
            'matchDate': obj.matchDate.strftime("%Y-%m-%d %H:%M:%S")
        }
```

- 匹配结果的API资源

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/900db4cce8f14275b9f8780a09446ba9.png)

  ```python
  from flask_restful import Resource
  from flask_restful.reqparse import RequestParser
  from Financial.resources.transaction.serializer import MatchedResultPaginateSerializer
  from comment.models import db
  from comment.models.matched_result import Matched_result


  # 匹配结果
  class MatchedResult(Resource):

      def get(self):
          rp = RequestParser()
          rp.add_argument('start')
          rp.add_argument('end')
          rp.add_argument('curPage')
          rp.add_argument('perPage')

          args = rp.parse_args()

          curPage = int(args.get('curPage'))
          perPage = int(args.get('perPage'))
          start = args.get('start')
          end = args.get('end')

          matchedList = Matched_result.query

          if start and end:
              matchedList = matchedList.filter(db.cast(Matched_result.matchDate, db.DATE) >= db.cast(start, db.DATE)).filter(
                  db.cast(Matched_result.matchDate, db.DATE) <= db.cast(end, db.DATE)).paginate(curPage, perPage, error_out=False)
          else:
              matchedList = matchedList.paginate(curPage, perPage, error_out=False)
          data = MatchedResultPaginateSerializer(matchedList).to_dict()

          return {'msg': 'success', 'data': data}

  ```

##### 14.6 蓝图绑定api 资源

- transaction包下init文件

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/481/1534444597910962176/05d5a6dc091447d382ef38aa3f0e7683.png)

  ```python
  from Financial.resources.transaction.loan_resource import MyLoan
  from Financial.resources.transaction.matched_result_resource import MatchedResult
  from Financial.resources.transaction.repayPlan_resource import RepayPlan
  from Financial.resources.transaction.investIncome_resource import InvestIncome

  transaction_api.add_resource(ExpectedReturn, '/exceptedReturn', endpoint='exceptedReturn')
  transaction_api.add_resource(RepayPlan, '/RepayPlan', endpoint='RepayPlan')
  transaction_api.add_resource(MatchedResult, '/matchedResult', endpoint='matchedResult')
  transaction_api.add_resource(InvestIncome, '/getIncome', endpoint='getIncome')
  ```
